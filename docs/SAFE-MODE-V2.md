# Safe Mode & Health Check Architecture (v2)

> Supersedes [SAFE-MODE.md](SAFE-MODE.md). Covers the refactored architecture where the health check monolith has been split into focused, single-responsibility scripts with proper systemd integration.
>
> **Updated Feb 20 2026** to reflect the simplification plan implementation (see [SIMPLIFICATION-PLAN.md](SIMPLIFICATION-PLAN.md) for full details). Key changes: settle time 45‚Üí10s, TimeoutStartSec 420‚Üí180s, unified config generator (`generate-config.sh`), shared libraries (`lib-env.sh`, `lib-auth.sh`), E2E/intro separation, single-phase provisioning.

## Overview

When an OpenClaw gateway fails to start or its agents can't communicate (bad API key, expired OAuth, invalid bot token), the system automatically detects the problem, attempts recovery with backup credentials, and brings a diagnostic SafeModeBot online to help the user troubleshoot.

The health check system works identically across all three isolation modes ‚Äî **single** (`none`), **session**, and **container** ‚Äî using a universal per-group pattern.

---

## Table of Contents

1. [Design Principles](#design-principles)
2. [Boot Sequence](#boot-sequence)
3. [Architecture Overview](#architecture-overview)
4. [Script Responsibilities](#script-responsibilities)
5. [Systemd Unit Structure](#systemd-unit-structure)
6. [Health Check Flow](#health-check-flow)
7. [Recovery Flow](#recovery-flow)
8. [Notification Flow](#notification-flow)
9. [Isolation Modes](#isolation-modes)
10. [State Files & Paths](#state-files--paths)
11. [Exit Codes](#exit-codes)
12. [Permissions](#permissions)
13. [Known Issues & Gotchas](#known-issues--gotchas)
14. [Debugging](#debugging)
15. [Test Habitats](#test-habitats)

---

## Design Principles

### 1. No Services Before Reboot

**OpenClaw services MUST NOT start until after the post-install reboot.**

During initial boot (phase1 + phase2):
- Services are **enabled** (`systemctl enable`) but **never started**
- `generate-session-services.sh` checks for `boot-complete` marker ‚Äî if missing, it only enables
- Config files, workspaces, and state directories are written and prepared
- After phase2 completes, the system reboots

**Why the reboot is required:**
- Packages installed in parallel may need kernel modules loaded
- systemd unit files written during cloud-init need `daemon-reload` (reboot is the cleanest reset)
- Avoids weird state from halfway-installed packages (Chrome, xrdp, etc.)
- Services should only start in a known-clean environment

After reboot:
- Services auto-start via systemd (`WantedBy=multi-user.target`)
- Health check runs exactly **once** per service (one per isolation group)
- E2E tests verify all agents can respond

### 2. Account Name = Agent ID

Bot tokens are stored under accounts named after the agent ID ‚Äî **never** `default`:

| Agent ID | Account Name | Config Path |
|----------|-------------|-------------|
| `agent1` | `agent1` | `channels.telegram.accounts.agent1.botToken` |
| `agent2` | `agent2` | `channels.telegram.accounts.agent2.botToken` |
| `safe-mode` | `safe-mode` | `channels.telegram.accounts.safe-mode.botToken` |

Using `default` causes two problems:
- `--reply-account agent1` can't find a token named `default`
- Duplicating tokens under both `default` and `agent1` creates **two polling instances** on the same token ‚Üí Telegram 409 conflicts

### 3. Gateway Must Bind to Loopback

Health check and safe mode recovery use `openclaw agent --deliver` via the CLI. The gateway **must** bind to `loopback` (not `lan`). With `bind: "lan"`, the CLI gets "pairing required" errors because it connects via 127.0.0.1 which doesn't match the LAN binding.

### 4. Permissions Set During Creation

All directories and files are created with correct ownership from the start using `lib-permissions.sh`. No deferred `chown -R` calls. See [Permissions](#permissions).

### 5. Build Failures Must Be Fatal

If `build-full-config.sh` fails during phase2, a `build-failed` marker is written and `phase2-complete` is **never** touched. This prevents the system from rebooting into a broken state.

### 6. Env-Var-Only Timeouts

All health check timeouts are configurable via environment variables with production defaults. Nothing is hardcoded for testing ‚Äî tests pass env vars, nothing to revert.

### 7. Single Source of Truth

All JSON configs are generated by `generate-config.sh` using `jq` ‚Äî no bash string interpolation for JSON values. Token validation lives in `lib-auth.sh`, auth header construction in `get_auth_header()`, notifications in `lib-notify.sh`. Each function exists in exactly one place.

### 8. Shared Libraries

Common code is extracted into libraries deployed to `/usr/local/sbin/`:
- `lib-env.sh` ‚Äî base64 decode, env loading
- `lib-auth.sh` ‚Äî token validation, auth headers, provider discovery
- `lib-notify.sh` ‚Äî Telegram/Discord notifications, SafeModeBot intro
- `lib-health-check.sh` ‚Äî health check utilities
- `lib-permissions.sh` ‚Äî file/dir ownership

All library sourcing uses fatal guards (`type fn &>/dev/null || exit 1`) to fail fast on missing dependencies.

---

## Boot Sequence

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PROVISIONING (cloud-init)                      ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  cloud-init runcmd ‚Üí bootstrap.sh ‚Üí provision.sh                 ‚îÇ
‚îÇ  (Sequential, no background fork)                                ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Stage 1: Parse config, install Node/jq                          ‚îÇ
‚îÇ  Stage 2: Install OpenClaw, create user                          ‚îÇ
‚îÇ  Stage 3: Install desktop environment                            ‚îÇ
‚îÇ  Stage 4: Install developer tools                                ‚îÇ
‚îÇ  Stage 5: Install browser & pip packages                         ‚îÇ
‚îÇ  Stage 6: Configure desktop & remote access                      ‚îÇ
‚îÇ  Stage 7: Install skills & apps                                  ‚îÇ
‚îÇ  Stage 8: Build configs & generate services                      ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  build-full-config.sh (branches by isolation mode):              ‚îÇ
‚îÇ    ‚îå‚îÄ none (single) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ    ‚îÇ Rebuild openclaw.service WITH ExecStartPost             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ Generate openclaw-safeguard.path + .service             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ Generate openclaw-e2e.service                           ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ systemctl enable all                                    ‚îÇ   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ    ‚îå‚îÄ session ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ    ‚îÇ generate-session-services.sh:                           ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   For each group: openclaw-{group}.service              ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ                   openclaw-safeguard-{group}.path + svc ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ                   openclaw-e2e-{group}.service           ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   Disable bootstrap openclaw.service                    ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   systemctl enable all per-group units                  ‚îÇ   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ    ‚îå‚îÄ container ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ    ‚îÇ generate-docker-compose.sh:                             ‚îÇ   ‚îÇ
‚îÇ    ‚îÇ   Per-group Docker containers (health checks TBD)       ‚îÇ   ‚îÇ
‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Stage 9: Fix permissions, REBOOT                                ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚ö†Ô∏è  If build-full-config.sh fails:                              ‚îÇ
‚îÇ      ‚Üí Write build-failed marker                                 ‚îÇ
‚îÇ      ‚Üí Do NOT reboot into broken state                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                               ‚îÇ
                               ‚ñº REBOOT
                               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        POST-REBOOT                               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  systemd starts all enabled services automatically               ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Per isolation mode:                                             ‚îÇ
‚îÇ    none:      openclaw.service (rebuilt with health check)        ‚îÇ
‚îÇ    session:   openclaw-{group}.service per group                 ‚îÇ
‚îÇ    container: docker compose up                                  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  Each service's lifecycle (see Architecture Overview below):     ‚îÇ
‚îÇ    1. Gateway starts (ExecStart)                                 ‚îÇ
‚îÇ    2. HTTP health check (ExecStartPost) ‚Äî lightweight            ‚îÇ
‚îÇ    3. E2E check (separate service) ‚Äî thorough                    ‚îÇ
‚îÇ    4. If unhealthy ‚Üí safeguard handler (triggered by .path)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Single-Phase Provisioning

`provision.sh` runs sequentially from cloud-init's `runcmd` context ‚Äî no background fork, no race conditions. All package installs, config generation, and service creation happen in a single script with 9 progress stages. The script ends with a reboot.

**Legacy fallback:** `bootstrap.sh` auto-detects: if `provision.sh` exists, it uses it. Otherwise, it falls back to the legacy `phase1-critical.sh` + `phase2-background.sh` two-phase path (kept in the repo for older hatchery versions).

> **Note:** `provision.sh` has an inline `d()` base64 decode fallback because it runs before `lib-env.sh` is deployed to `/usr/local/sbin/`.

---

## Architecture Overview

The health check system uses three separate systemd units per isolation group:

```
openclaw-{group}.service                    ‚Üê Main gateway process
  ‚îÇ
  ‚îî‚îÄ ExecStartPost: gateway-health-check.sh ‚Üê HTTP-only, ~100 lines
       ‚îÇ
       ‚îú‚îÄ HTTP responds? ‚Üí exit 0 ‚Üí service becomes "active"
       ‚îÇ                              ‚îÇ
       ‚îÇ                              ‚ñº
       ‚îÇ                    openclaw-e2e-{group}.service
       ‚îÇ                    (BindsTo main, starts when active)
       ‚îÇ                      ‚îÇ
       ‚îÇ                      ‚îú‚îÄ Channel tokens OK?
       ‚îÇ                      ‚îú‚îÄ All agents respond to prompts?
       ‚îÇ                      ‚îÇ
       ‚îÇ                      ‚îú‚îÄ YES ‚Üí ‚úÖ Healthy, agents introduce themselves
       ‚îÇ                      ‚îÇ
       ‚îÇ                      ‚îî‚îÄ NO ‚Üí writes /var/lib/init-status/unhealthy-{group}
       ‚îÇ                                ‚îÇ
       ‚îÇ                                ‚ñº
       ‚îÇ                      openclaw-safeguard-{group}.path  (watches marker)
       ‚îÇ                        ‚îÇ
       ‚îÇ                        ‚îî‚îÄ openclaw-safeguard-{group}.service
       ‚îÇ                             ‚îÇ
       ‚îÇ                             ‚îî‚îÄ safe-mode-handler.sh
       ‚îÇ                                  ‚îú‚îÄ Smart recovery (find working creds)
       ‚îÇ                                  ‚îú‚îÄ Notify user
       ‚îÇ                                  ‚îú‚îÄ Restart service with safe config
       ‚îÇ                                  ‚îî‚îÄ SafeModeBot introduces itself
       ‚îÇ
       ‚îî‚îÄ HTTP not responding? ‚Üí writes unhealthy marker ‚Üí exit 1
            ‚îÇ                      (also triggers safeguard)
            ‚îÇ
            ‚îî‚îÄ systemd Restart=always ‚Üí retries gateway start
```

### Why Three Separate Units?

**Before (monolith):** A single 1500-line `gateway-health-check.sh` ran as `ExecStartPost`. It did HTTP polling, E2E testing, recovery, notifications, config swapping, and service restarts ‚Äî all in one script. Problems:
- Service stayed in "activating" state for minutes while E2E ran
- Self-referential restarts (`systemctl restart` from inside ExecStartPost) caused SIGTERM races
- No separation between "is the process alive?" and "can agents talk?"
- Difficult to test individual components

**After (three units):**

| Unit | Responsibility | Lines | Runs as |
|------|---------------|-------|---------|
| `gateway-health-check.sh` | HTTP endpoint responding? | ~100 | ExecStartPost (blocking) |
| `gateway-e2e-check.sh` | Agents can actually communicate? | ~350 | Separate oneshot service |
| `safe-mode-handler.sh` | Recovery + notification | ~300 | Triggered by .path watcher |

Benefits:
- Service reaches "active" state quickly (just HTTP check)
- E2E runs asynchronously, doesn't block service status
- Recovery is reactive (triggered by marker file), not inline
- Each component can be tested independently
- No self-referential `systemctl restart` from ExecStartPost

---

## Script Responsibilities

### `gateway-health-check.sh` (~103 lines)

**Purpose:** Verify the gateway HTTP endpoint is alive. Nothing else.

**Called by:** `ExecStartPost` in the main service unit.

**Flow:**
1. Wait `HEALTH_CHECK_SETTLE_SECS` (default: **10s**) for gateway to initialize
2. Poll `http://127.0.0.1:${PORT}/` every 5 seconds
3. While polling, check if the gateway process is still alive (`pgrep -f "openclaw.gateway"`)
4. At `HEALTH_CHECK_WARN_SECS` (default: 120s), send a "still waiting" notification
5. At `HEALTH_CHECK_HARD_MAX_SECS` (default: 300s), give up

**Exit codes:**
- `0` ‚Äî HTTP responding, service becomes "active"
- `1` ‚Äî Failed, writes unhealthy marker, systemd restarts (`Restart=always`)

**Process-alive detection:** The script tracks whether the gateway process has been seen. If the process was running and then vanishes (crash), it fails immediately. If the process never appears within 60 seconds, it also fails. This prevents waiting 5 minutes for a process that crashed on startup.

**Sources:** `lib-health-check.sh`, `lib-env.sh`

### `gateway-e2e-check.sh` (~340 lines)

**Purpose:** Verify agents can actually respond to messages. Runs after the gateway HTTP endpoint is confirmed alive. **E2E testing is separate from agent intros** ‚Äî the health check uses a deterministic test prompt and never sends `--deliver`.

**Called by:** `openclaw-e2e-{group}.service` (separate systemd unit, `BindsTo` main service).

**Normal mode flow:**
1. `check_channel_connectivity()` ‚Äî validate every agent's bot token via API (uses `validate_telegram_token()` / `validate_discord_token()` from `lib-auth.sh`)
2. `check_agents_e2e()` ‚Äî prompt each agent with `"Reply with exactly: HEALTH_CHECK_OK"` using `--json` (no `--deliver`), verify it responds
3. All pass ‚Üí mark healthy, then `send_agent_intros()` (separate, only on fresh boot ‚Äî gated by `INTRO_SENT_MARKER`)
4. Any fail ‚Üí write unhealthy marker (triggers safeguard .path unit)

**Safe mode flow (Run 2):**
1. `check_agents_e2e "safe-mode"` ‚Äî same unified function, just testing the safe-mode agent
2. Pass ‚Üí mark safe mode stable, `notify_send_safe_mode_intro()` from `lib-notify.sh`
3. Fail ‚Üí write unhealthy marker again (safeguard will try another recovery attempt)

**Always exits 0** ‚Äî recovery is handled by the safeguard unit, not this script. It only writes the unhealthy marker file to signal the problem.

**Sources:** `lib-health-check.sh`, `lib-notify.sh`, `lib-auth.sh`

**Key design: E2E is re-runnable.** Because the test prompt is deterministic and doesn't use `--deliver`, health checks can be re-run (e.g., after config updates) without spamming intro messages. Intros are gated by a per-group marker file (`/var/lib/init-status/intro-sent{-GROUP}`) and only fire once per boot.

### `safe-mode-handler.sh` (~270 lines)

**Purpose:** Handle safe mode entry, credential recovery, and user notification. Completely separated from health checking.

**Triggered by:** `openclaw-safeguard-{group}.path` watching `/var/lib/init-status/unhealthy-{group}`.

**Flow:**
1. Check recovery attempt count (max 2)
2. Source `safe-mode-recovery.sh` (smart credential discovery)
3. Run recovery ‚Äî find working chat tokens + API keys
4. If recovery fails, fall back to `openclaw.emergency.json`
5. Mark safe mode state
6. Notify user (via raw API ‚Äî instant, no LLM needed)
7. Generate `BOOT_REPORT.md` for SafeModeBot
8. Restart the gateway service with the safe config
9. `notify_send_safe_mode_intro()` ‚Äî SafeModeBot introduces itself with AI-powered diagnostics (shared function from `lib-notify.sh`)

**Exit codes:**
- `0` ‚Äî Recovery succeeded, service restarted
- `1` ‚Äî Recovery attempted, needs restart (systemd handles)
- `2` ‚Äî Critical failure after max attempts, gave up

**Sources:** `lib-health-check.sh`, `lib-notify.sh` (which brings in `lib-auth.sh`)

### `lib-health-check.sh` (~150 lines)

**Purpose:** Shared utilities sourced by all health check scripts.

**Provides:**
- `hc_init_logging(group)` ‚Äî set up log file and run ID
- `hc_load_environment()` ‚Äî source env files, set up common variables
- `get_owner_id_for_platform(platform)` ‚Äî resolve owner/user ID
- `hc_is_in_safe_mode()` ‚Äî check safe mode marker
- `hc_get_recovery_attempts()` ‚Äî read recovery counter
- All shared variables: `CONFIG_PATH`, `SAFE_MODE_FILE`, `HC_SERVICE_NAME`, etc.

### `lib-notify.sh` (~230 lines)

**Purpose:** Notification library for Telegram and Discord. Also hosts the shared SafeModeBot intro logic.

**Sources:** `lib-auth.sh` (for `validate_telegram_token()`, `validate_discord_token()`)

**Provides:**
- `send_telegram_notification(token, chat_id, message)` ‚Äî low-level Telegram send
- `send_discord_notification(token, owner_id, message)` ‚Äî low-level Discord send (auto-converts HTML to markdown)
- `notify_find_token()` ‚Äî search for any working notification token (sets `NOTIFY_PLATFORM`, `NOTIFY_TOKEN`, `NOTIFY_OWNER`)
- `notify_send_message(text)` ‚Äî send via discovered token (HTML supported for Telegram, auto-converted for Discord)
- `notify_send_safe_mode_intro()` ‚Äî generate boot report, send SafeModeBot intro via `openclaw agent --deliver` (shared by `gateway-e2e-check.sh` and `safe-mode-handler.sh`)

**Token validation:** Delegated to `lib-auth.sh` (`validate_telegram_token()`, `validate_discord_token()`). No local token validation functions ‚Äî `lib-notify.sh` sources `lib-auth.sh` on load.

**Token discovery order:**
1. Safe mode config tokens (if in safe mode)
2. Habitat agent tokens (preferred platform first)
3. Cross-platform fallback (e.g., Telegram failed ‚Üí try Discord)

### `safe-mode-recovery.sh`

**Purpose:** Smart credential discovery. Finds working chat tokens and API keys from all available sources.

**Token discovery:**
1. Try user's configured platform first (telegram/discord)
2. Try ALL agent tokens on that platform (filtered by GROUP in session isolation)
3. If none work, try fallback platform
4. Record which agent/token works

**API provider discovery:**
1. Try user's configured provider
2. Fallback order: anthropic ‚Üí openai ‚Üí google
3. Check OAuth profiles first, then API keys
4. Trust Anthropic OAuth tokens (`sk-ant-oat*`) without API validation

### `lib-auth.sh` (~333 lines)

**Purpose:** Single source of truth for authentication ‚Äî token validation, auth header construction, provider discovery, and token hunting. Extracted from `safe-mode-recovery.sh` to eliminate duplication.

**Provides:**
- `get_auth_header(provider, token)` ‚Äî returns correct HTTP header (`x-api-key` vs `Authorization: Bearer` for Anthropic OAuth, etc.)
- `validate_telegram_token(token)` ‚Äî call `getMe`, check response (with `TEST_MODE` support)
- `validate_discord_token(token)` ‚Äî call `/users/@me`, check response (with `TEST_MODE` support)
- `validate_api_key(provider, key)` ‚Äî provider-aware validation, sets `VALIDATION_REASON`; trusts OAuth tokens (`sk-ant-oat*`) without API call
- `find_working_telegram_token()` / `find_working_discord_token()` ‚Äî search agents by group, set `FOUND_TOKEN_RESULT`
- `find_working_platform_token()` ‚Äî try preferred platform, then cross-platform fallback
- `find_working_api_provider()` ‚Äî try providers in fallback order (user's default ‚Üí anthropic ‚Üí openai ‚Üí google)
- `get_provider_from_model(model)` ‚Äî extract provider from model string (`anthropic/claude-opus-4-5` ‚Üí `anthropic`)
- `get_provider_order()` / `get_default_model_for_provider(provider)` ‚Äî provider utilities

**Global result variables:** Uses `FOUND_TOKEN_RESULT`, `FOUND_API_PROVIDER`, `VALIDATION_REASON` to avoid subshell issues with `$()`.

### `lib-env.sh` (~44 lines)

**Purpose:** Shared environment loading. Eliminates the `d()` base64 decoder that was copy-pasted across 10+ scripts.

**Provides:**
- `d(value)` ‚Äî base64 decode helper (empty input ‚Üí empty output)
- `env_load()` ‚Äî source `/etc/droplet.env` and `/etc/habitat-parsed.env` (respects `TEST_MODE`)
- `env_decode_keys()` ‚Äî decode common API keys from base64 env vars (won't overwrite pre-set values)

### `generate-config.sh` (~496 lines)

**Purpose:** Single source of truth for all OpenClaw JSON config generation. Uses `jq` exclusively ‚Äî zero bash string interpolation for JSON values. Replaces 5 separate heredoc config generators.

**Modes:**
- `--mode full` ‚Äî full production config (all agents, channels, env, browser, skills)
- `--mode session --group NAME --port PORT` ‚Äî per-group session config (filtered agents)
- `--mode safe-mode --token TOKEN --provider PROVIDER` ‚Äî safe mode recovery config

**Composable builder functions:** `build_gateway`, `build_agents`, `build_telegram_channel`, `build_discord_channel`, `build_bindings`, `build_env`, `build_auth_profiles`

**Called by:** `build-full-config.sh` (full mode), `generate-session-services.sh` (session mode), `safe-mode-recovery.sh` (safe-mode mode)

### Deployment Paths

| Script | Installed to |
|--------|-------------|
| `lib-env.sh` | `/usr/local/sbin/` |
| `lib-auth.sh` | `/usr/local/sbin/` |
| `lib-health-check.sh` | `/usr/local/sbin/` |
| `lib-notify.sh` | `/usr/local/sbin/` |
| `lib-permissions.sh` | `/usr/local/sbin/` |
| `generate-config.sh` | `/usr/local/bin/` |
| `gateway-health-check.sh` | `/usr/local/bin/` |
| `gateway-e2e-check.sh` | `/usr/local/bin/` |
| `safe-mode-handler.sh` | `/usr/local/bin/` |
| `safe-mode-recovery.sh` | `/usr/local/bin/` |
| `provision.sh` | `/usr/local/sbin/` |

---

## Systemd Unit Structure

### Single Mode (`isolation: none`)

```
openclaw.service
  ‚îî‚îÄ ExecStartPost: gateway-health-check.sh

openclaw-e2e.service
  ‚îî‚îÄ BindsTo: openclaw.service
  ‚îî‚îÄ ExecStart: gateway-e2e-check.sh

openclaw-safeguard.path
  ‚îî‚îÄ PathExists: /var/lib/init-status/unhealthy
  ‚îî‚îÄ Activates: openclaw-safeguard.service

openclaw-safeguard.service
  ‚îî‚îÄ ExecStart: safe-mode-handler.sh
```

### Session Mode (`isolation: session`)

Per group (e.g., `browser`, `documents`):

```
openclaw-browser.service
  ‚îî‚îÄ ExecStartPost: gateway-health-check.sh
  ‚îî‚îÄ Environment: GROUP=browser, GROUP_PORT=18790

openclaw-e2e-browser.service
  ‚îî‚îÄ BindsTo: openclaw-browser.service
  ‚îî‚îÄ ExecStart: gateway-e2e-check.sh
  ‚îî‚îÄ Environment: GROUP=browser, GROUP_PORT=18790

openclaw-safeguard-browser.path
  ‚îî‚îÄ PathExists: /var/lib/init-status/unhealthy-browser

openclaw-safeguard-browser.service
  ‚îî‚îÄ ExecStart: safe-mode-handler.sh
  ‚îî‚îÄ Environment: GROUP=browser, GROUP_PORT=18790, RUN_MODE=path-triggered
```

### Container Mode (`isolation: container`)

Each Docker container runs its own gateway + health check:

```yaml
services:
  browser:
    container_name: openclaw-browser
    environment:
      - GROUP=browser
      - GROUP_PORT=18789
      - ISOLATION=container
    volumes:
      - /usr/local/bin/gateway-health-check.sh:/usr/local/bin/gateway-health-check.sh:ro
      - /etc/droplet.env:/etc/droplet.env:ro
      - /var/lib/init-status:/var/lib/init-status
```

Recovery uses `docker restart` instead of `systemctl restart`.

> **Note:** Container health checks are not yet fully implemented. The per-group pattern exists but the Docker entrypoint integration is TBD.

### Key Systemd Settings

| Setting | Value | Why |
|---------|-------|-----|
| `Restart` | `on-failure` | Restart on crash, not on clean exit |
| `RestartPreventExitStatus` | `2` | Exit 2 = critical, don't retry |
| `RestartSec` | `10` | Wait 10s between restart attempts |
| `TimeoutStartSec` | `180` | 10s settle + 60s no-process timeout + buffer (was 420 with old monolith) |
| `TimeoutStartSec` (E2E) | `600` | Agent intros can be slow |
| `BindsTo` (E2E) | main service | E2E dies when main service stops |
| `Requisite` (E2E) | main service | Don't start E2E unless main is active |

**On `Restart=always`:** The service restarts after any exit, including clean exits (exit 0) from SIGUSR1-based restarts (e.g., the `/restart` Discord command). It will **not** restart after:
- `systemctl stop` (systemd always excludes intentional stops regardless of restart policy)
- Critical failure with exit code 2 (via `RestartPreventExitStatus=2`)

---

## Health Check Flow

### Stage 1: HTTP Check (ExecStartPost)

The lightest possible check ‚Äî is the process alive and accepting HTTP?

```
gateway-health-check.sh
‚îÇ
‚îú‚îÄ Skip if recently recovered (within 120s)
‚îÇ
‚îú‚îÄ Wait SETTLE seconds (10s default)
‚îÇ
‚îú‚îÄ Poll http://127.0.0.1:PORT/ every 5s
‚îÇ   ‚îú‚îÄ Track process with pgrep "openclaw.gateway"
‚îÇ   ‚îú‚îÄ Process seen then vanished? ‚Üí FAIL immediately (crash)
‚îÇ   ‚îú‚îÄ Process never appeared after 60s? ‚Üí FAIL
‚îÇ   ‚îú‚îÄ At WARN_AT seconds (120s) ‚Üí send "still waiting" notification
‚îÇ   ‚îî‚îÄ At HARD_MAX seconds (300s) ‚Üí FAIL (timeout)
‚îÇ
‚îú‚îÄ HTTP 200? ‚Üí exit 0 (service becomes "active")
‚îÇ
‚îî‚îÄ Failed? ‚Üí write unhealthy marker ‚Üí exit 1
              (systemd restarts via on-failure)
```

### Stage 2: E2E Agent Check (Separate Service)

Runs only after Stage 1 passes (service is "active").

```
gateway-e2e-check.sh
‚îÇ
‚îú‚îÄ Is this safe mode (Run 2)?
‚îÇ   ‚îî‚îÄ YES ‚Üí check_agents_e2e("safe-mode")  ‚Üê unified function
‚îÇ            ‚îÇ Prompt: "Reply with exactly: HEALTH_CHECK_OK" (--json, no --deliver)
‚îÇ            ‚îú‚îÄ Pass ‚Üí mark stable, notify_send_safe_mode_intro() ‚Üí exit 0
‚îÇ            ‚îî‚îÄ Fail ‚Üí write unhealthy marker ‚Üí exit 0
‚îÇ
‚îî‚îÄ Normal mode:
    ‚îÇ
    ‚îú‚îÄ check_channel_connectivity()
    ‚îÇ   ‚îÇ For each agent in this group:
    ‚îÇ   ‚îÇ   validate_telegram_token() / validate_discord_token() (from lib-auth.sh)
    ‚îÇ   ‚îÇ   Must have at least one valid token per platform config
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ All tokens valid ‚Üí continue to E2E
    ‚îÇ   ‚îî‚îÄ Any token invalid ‚Üí write unhealthy marker ‚Üí exit 0
    ‚îÇ
    ‚îú‚îÄ check_agents_e2e()  ‚Üê same function as safe mode path
    ‚îÇ   ‚îÇ For each agent in this group:
    ‚îÇ   ‚îÇ   openclaw agent --agent {id}
    ‚îÇ   ‚îÇ     --message "Reply with exactly: HEALTH_CHECK_OK"
    ‚îÇ   ‚îÇ     --json --timeout 30 (NO --deliver)
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ All respond ‚Üí ‚úÖ healthy
    ‚îÇ   ‚îî‚îÄ Any fail ‚Üí write unhealthy marker ‚Üí exit 0
    ‚îÇ
    ‚îî‚îÄ send_agent_intros()  ‚Üê SEPARATE from E2E, only on fresh boot
        ‚îÇ Gated by INTRO_SENT_MARKER file
        ‚îÇ For each agent in this group:
        ‚îÇ   openclaw agent --agent {id} --message "introduce yourself"
        ‚îÇ     --deliver --reply-channel {platform}
        ‚îÇ     --reply-account {id} --reply-to {owner}
        ‚îÇ
        ‚îî‚îÄ Touch INTRO_SENT_MARKER ‚Üí exit 0
```

**Why channel check before E2E?** OpenClaw has a delivery-recovery feature that silently falls back to other accounts when a token fails. Without the explicit token validation, a broken Telegram token is invisible ‚Äî the agent responds fine (LLM works), and delivery succeeds through another agent's token. The channel check catches broken tokens that OpenClaw's recovery would otherwise mask.

### Stage 3: Safe Mode Recovery (Triggered by .path)

Only runs when an unhealthy marker appears.

```
safe-mode-handler.sh
‚îÇ
‚îú‚îÄ Already exhausted max recovery attempts (2)?
‚îÇ   ‚îî‚îÄ YES ‚Üí üî¥ CRITICAL: notify user, exit 2 (stop permanently)
‚îÇ
‚îú‚îÄ Source safe-mode-recovery.sh
‚îÇ
‚îú‚îÄ Run smart recovery
‚îÇ   ‚îú‚îÄ Find working chat token (by group, preferred platform first)
‚îÇ   ‚îú‚îÄ Find working API key (anthropic ‚Üí openai ‚Üí google)
‚îÇ   ‚îú‚îÄ Generate safe mode config
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ SUCCESS ‚Üí apply recovered config
‚îÇ   ‚îî‚îÄ FAILED ‚Üí copy openclaw.emergency.json as fallback
‚îÇ
‚îú‚îÄ Mark safe mode state
‚îú‚îÄ Increment recovery counter
‚îÇ
‚îú‚îÄ Send notification (raw API, instant)
‚îÇ   "‚ö†Ô∏è [Habitat] Entering Safe Mode ‚Äî SafeModeBot will follow up"
‚îÇ
‚îú‚îÄ Generate BOOT_REPORT.md (diagnostics for SafeModeBot)
‚îÇ
‚îú‚îÄ Restart gateway service with safe config
‚îÇ   (This triggers ExecStartPost ‚Üí HTTP check ‚Üí E2E check (Run 2))
‚îÇ
‚îú‚îÄ Service up? ‚Üí notify_send_safe_mode_intro() from lib-notify.sh
‚îÇ   (Generates BOOT_REPORT.md, SafeModeBot reads it, delivers AI diagnostics)
‚îÇ
‚îî‚îÄ Service won't start? ‚Üí exit 2 (critical)
```

---

## Recovery Flow

### Two Recovery Mechanisms

#### 1. Smart Recovery (Runtime)

Dynamic credential discovery when the health check fails.

**Token search order:**
1. User's configured platform first (telegram/discord)
2. All agent tokens on that platform (filtered by GROUP)
3. Cross-platform fallback

**API key search order:**
1. User's configured provider for agent1
2. Anthropic ‚Üí OpenAI ‚Üí Google
3. OAuth profiles checked first, then API keys
4. Anthropic OAuth tokens (`sk-ant-oat*`) trusted without API validation

#### 2. Emergency Config (Static Fallback)

Pre-built config created at boot time by `phase1-critical.sh`. Used when the smart recovery script itself fails (bug, syntax error, all credentials broken).

Uses agent1's **exact** settings:
- Model: `AGENT1_MODEL` (no fallback)
- API key: based on model provider
- Bot token: `AGENT1_BOT_TOKEN` (no searching)

Intentionally simple ‚Äî no fallback logic means no fallback bugs.

### Recovery Attempt Limits

| Attempt | What Happens |
|---------|-------------|
| 1st | Smart recovery ‚Üí find working creds ‚Üí restart |
| 2nd | Smart recovery again ‚Üí maybe different creds ‚Üí restart |
| 3rd+ | üî¥ CRITICAL ‚Äî notify user, stop permanently (exit 2) |

The counter is stored in `/var/lib/init-status/recovery-attempts{-GROUP}` and cleared on successful health check.

---

## Notification Flow

Notifications are sent **once per boot** (duplicate prevention via marker files).

### Scenarios

| Scenario | What User Receives |
|----------|-------------------|
| Healthy boot | Each agent introduces itself (via E2E check delivery) |
| Safe mode recovery works | ‚ö†Ô∏è Script notification (instant) + SafeModeBot intro (AI diagnostics) |
| Everything broken | üî¥ CRITICAL notification only (raw API) |

### Healthy Boot

After the E2E check passes, `send_agent_intros()` runs as a **separate step** (not during health check). Each agent introduces itself through its own bot token:

```bash
# E2E check (fast, deterministic, re-runnable):
openclaw agent --agent "$agent_id" \
  --message "Reply with exactly: HEALTH_CHECK_OK" \
  --json --timeout 30

# Intro (separate, only on fresh boot ‚Äî gated by INTRO_SENT_MARKER):
openclaw agent --agent "$agent_id" \
  --message "You just came online after a reboot. Reply with a brief introduction..." \
  --deliver --reply-channel "$platform" \
  --reply-account "$agent_id" \
  --reply-to "$owner_id"
```

**Re-running health checks will NOT re-send intros** ‚Äî the marker file prevents it.

### Safe Mode Boot (Two Messages)

1. **Script notification** (instant, raw API) ‚Äî no LLM needed:
   > ‚ö†Ô∏è **[MyHabitat] Entering Safe Mode**
   > Health check failed. Recovering with backup configuration.
   > SafeModeBot will follow up shortly with diagnostics.

2. **SafeModeBot intro** (seconds later, via `openclaw agent --deliver`) ‚Äî AI-generated:
   > Hi, I'm SafeModeBot running in emergency mode. Your agent1 Telegram token appears invalid (got 404 from getMe). I'm running on Anthropic Claude with a Google API key fallback. Want me to help you generate a new bot token?

Both are needed: the script notification is immediate and guaranteed, while the SafeModeBot intro provides intelligent diagnostics from reading `BOOT_REPORT.md`.

### Critical Failure

Raw API notification only ‚Äî no bot is available:
> üî¥ **[MyHabitat] CRITICAL FAILURE**
> Gateway failed after 2 recovery attempts. Bot is OFFLINE.
> Check logs: `journalctl -u openclaw-browser -n 50`

### Notification Token Discovery

The notification system tries multiple sources to find a working token (it needs to send even when most credentials are broken):

1. Safe mode config tokens (if recovery already ran)
2. Habitat agent tokens (preferred platform first)
3. Cross-platform fallback (Telegram broken ‚Üí try Discord)

---

## Isolation Modes

### Universal Pattern

The same scripts run identically in all modes. Every invocation handles **one group**. The only differences are env vars and restart mechanism:

| Mode | Service Name | GROUP | PORT | Restart Method |
|------|-------------|-------|------|---------------|
| `none` (single) | `openclaw` | _(empty)_ | 18789 | `systemctl restart openclaw` |
| `session` | `openclaw-{group}` | e.g., `browser` | 18790+ | `systemctl restart openclaw-browser` |
| `container` | (inside Docker) | e.g., `browser` | 18789 | `docker restart openclaw-browser` |

### Single Mode (`isolation: none`)

One gateway, one set of health check units. `build-full-config.sh` rebuilds the bootstrap service with an ExecStartPost and generates safeguard + E2E units.

### Session Mode (`isolation: session`)

Multiple gateways, one per isolation group. `generate-session-services.sh` creates per-group service units, each with its own:
- Config at `~/.openclaw/configs/{group}/openclaw.session.json`
- State dir at `~/.openclaw-sessions/{group}/`
- Health check, E2E, and safeguard units
- Port assignment (18790, 18791, ...)

**Token filtering:** In session mode, health checks only validate tokens for agents in the current group (via `AGENT{N}_ISOLATION_GROUP` env vars). This prevents false failures from checking tokens belonging to another group.

The bootstrap `openclaw.service` is **disabled** when session services are created ‚Äî it's replaced by the per-group services.

### Container Mode (`isolation: container`)

Each container runs its own gateway. The health check scripts are mounted as read-only volumes. State directories (`/var/lib/init-status/`) are shared between containers and the host.

> Container health checks are not yet fully implemented. The per-group pattern and Docker compose generation exist, but the entrypoint integration is TBD.

---

## State Files & Paths

### Per-Group State Files

| File | Single Mode | Session Mode |
|------|------------|--------------|
| Safe mode flag | `/var/lib/init-status/safe-mode` | `/var/lib/init-status/safe-mode-{group}` |
| Unhealthy marker | `/var/lib/init-status/unhealthy` | `/var/lib/init-status/unhealthy-{group}` |
| Recovery counter | `/var/lib/init-status/recovery-attempts` | `/var/lib/init-status/recovery-attempts-{group}` |
| Recently recovered | `/var/lib/init-status/recently-recovered` | `/var/lib/init-status/recently-recovered-{group}` |
| Gateway failed | `/var/lib/init-status/gateway-failed` | `/var/lib/init-status/gateway-failed-{group}` |
| Notification marker | `/var/lib/init-status/notification-sent-*` | Same (includes status context) |
| Intro sent marker | `/var/lib/init-status/intro-sent` | `/var/lib/init-status/intro-sent-{group}` |

### Boot State Files

| File | Purpose |
|------|---------|
| `/var/lib/init-status/boot-complete` | Initial boot + reboot finished |
| `/var/lib/init-status/phase2-complete` | Phase 2 finished (reboot imminent) |
| `/var/lib/init-status/build-failed` | Build pipeline failed (blocks phase2-complete) |
| `/var/lib/init-status/stage` | Current provisioning stage number |
| `/var/lib/init-status/setup-complete` | All health checks passed |

### Config Files

| File | Purpose |
|------|---------|
| `~/.openclaw/openclaw.json` | Active config (single mode) |
| `~/.openclaw/openclaw.full.json` | Full config backup |
| `~/.openclaw/openclaw.emergency.json` | Static fallback (agent1's exact settings) |
| `~/.openclaw/configs/{group}/openclaw.session.json` | Per-group config (session mode) |

### Log Files

| File | Purpose |
|------|---------|
| `/var/log/gateway-health-check.log` | Single mode health check log |
| `/var/log/gateway-health-check-{group}.log` | Per-group health check log |
| `/var/log/safe-mode-diagnostics.txt` | Recovery diagnostics |
| `/var/log/init-stages.log` | Provisioning stage transitions |
| `/var/log/provision.log` | Phase 1+2 provisioning output |

---

## Exit Codes

### gateway-health-check.sh (ExecStartPost)

| Code | Meaning | Systemd Action |
|------|---------|----------------|
| 0 | HTTP responding | Service becomes "active" |
| 1 | HTTP failed | Write unhealthy marker, `Restart=always` |

### gateway-e2e-check.sh (E2E service)

| Code | Meaning | Action |
|------|---------|--------|
| 0 | Always | Writes unhealthy marker if E2E failed; safeguard handles recovery |

### safe-mode-handler.sh (Safeguard service)

| Code | Meaning | Action |
|------|---------|--------|
| 0 | Recovery succeeded, service restarted | Clean exit |
| 1 | Recovery attempted, needs retry | Systemd may restart |
| 2 | Critical failure, gave up | Stop permanently (`RestartPreventExitStatus=2`) |

---

## Permissions

All scripts use `lib-permissions.sh` for centralized, atomic permission management.

### Key Functions

| Function | Purpose |
|----------|---------|
| `ensure_bot_dir <path> [mode]` | Create directory with correct ownership |
| `ensure_bot_file <path> [mode]` | Fix file ownership and permissions |
| `fix_bot_permissions [home]` | Fix ALL standard directories |
| `fix_workspace_permissions [home]` | Fix `clawd/` tree |
| `fix_state_permissions [home]` | Fix `.openclaw*` tree |
| `fix_session_config_dir <dir>` | Fix systemd config directory |

### Permission Model

| Path | Mode | Reason |
|------|------|--------|
| `/home/bot` | 750 | Home dir, no world access |
| `~/.openclaw/` | 700 | Contains credentials |
| `~/.openclaw/*.json` | 600 | Config files with API keys |
| `~/.openclaw/agents/*/agent/auth-profiles.json` | 600 | OAuth tokens |
| `~/clawd/` | 755 | Workspace root |
| `~/clawd/agents/*/` | 755 | Agent workspaces |
| `~/.openclaw-sessions/` | 700 | Session isolation state |
| `/etc/systemd/system/{group}/openclaw.session.json` | 600 | Contains bot tokens |

### Why This Exists

Previously, permissions were set by scattered `chown -R` calls at the end of scripts. This caused a timing bug: services started before the `chown` ran, causing `EACCES: permission denied` errors and false safe mode triggers.

---

## Known Issues & Gotchas

### Anthropic OAuth Tokens
Anthropic OAuth tokens (`sk-ant-oat*`) cannot be validated via API (the `/v1/models` endpoint rejects them). The recovery script trusts them if present. They use `Authorization: Bearer` header, not `x-api-key`.

### OpenClaw Delivery Recovery Masks Broken Tokens
OpenClaw silently falls back to other bot accounts when delivery fails. A broken Telegram token is invisible to the E2E agent check because the agent responds fine (LLM works) and delivery succeeds through another account's token. This is why `check_channel_connectivity()` must run **before** `check_agents_e2e()`.

### iOS Shortcut Config Caching
iOS Shortcuts read files from Dropbox but may use a stale cache. You must open the Dropbox app and let it sync before running the Shortcut. The Shortcut shows a flat file list and cannot navigate subfolders.

### DDNS May Be Stale
Always check the DigitalOcean API for current droplet IPs. `dig +short` may return the old IP from a previous droplet.

### Google Auth in Session Isolation
OpenClaw has a bug where it can't find Google API keys from `auth-profiles.json` in session isolation. Workaround: use Anthropic for safe mode.

### Gateway Process Name
The OpenClaw binary spawns as `openclaw-gateway` (hyphenated). Use `openclaw.gateway` regex for `pgrep` to match both `openclaw-gateway` (binary name) and `openclaw gateway` (command args).

### Config Directory Ownership
Session config directories (`/etc/systemd/system/{group}/` or `~/.openclaw/configs/{group}/`) must be owned by the bot user. OpenClaw creates temporary files for atomic writes, and `EACCES` errors cause plugin auto-enable failures.

### Telegram Bot Rename Rate Limits
`rename-bots.sh` calls the Telegram `setMyName` API with aggressive rate limits (~18 hours between renames). Failures are non-fatal.

---

## Debugging

### Check Health Check Logs

```bash
# Single mode:
sudo cat /var/log/gateway-health-check.log

# Session isolation (per group):
sudo cat /var/log/gateway-health-check-browser.log
sudo cat /var/log/gateway-health-check-documents.log
```

### Check Recovery Diagnostics

```bash
sudo cat /var/log/safe-mode-diagnostics.txt
```

### Check Current State

```bash
# All state files:
ls -la /var/lib/init-status/

# Is safe mode active?
ls /var/lib/init-status/safe-mode*

# Recovery attempts:
cat /var/lib/init-status/recovery-attempts*
```

### Check Services

```bash
# Single mode:
systemctl status openclaw
systemctl status openclaw-e2e
systemctl status openclaw-safeguard.path

# Session mode:
systemctl status openclaw-browser
systemctl status openclaw-e2e-browser
systemctl status openclaw-safeguard-browser.path
```

### Check Config

```bash
# Active model:
jq '.agents.defaults.model' ~/.openclaw/openclaw.json

# Environment keys:
jq '.env | keys' ~/.openclaw/openclaw.json

# Account names:
jq '.channels.telegram.accounts | keys' ~/.openclaw/openclaw.json
```

### Check Permissions

```bash
ls -la ~/clawd/agents/
ls -la ~/.openclaw/
ls -la ~/.openclaw-sessions/        # session isolation only
ls -la ~/.openclaw/configs/          # session configs
```

### Via API (if gateway is running)

```bash
curl http://localhost:18789/status
```

### Collect Full Debug Bundle

```bash
sudo /usr/local/bin/collect-debug-logs.sh > /tmp/debug-bundle.txt
```

---

## Test Habitats

Test configs live in `Droplets/habitats/` on Dropbox:

| Habitat | Tests |
|---------|-------|
| `test-single-basic` | Single agent, all creds valid ‚Äî should pass |
| `test-single-broken-chat` | Broken bot token ‚Äî should trigger safe mode |
| `test-single-broken-llm` | Broken API key ‚Äî should trigger safe mode |
| `test-session-basic` | Session isolation, all valid ‚Äî should pass |
| `test-session-broken-group` | One group broken, one healthy |
| `test-container-basic` | Container isolation ‚Äî should pass |
| `test-container-broken` | Container with broken creds |
| `test-multi-platform-fallback` | Telegram broken ‚Üí Discord fallback |
| `SafeMode-BadToken` | Broken bot token ‚Üí recovery |
| `SafeMode-DiscordFallback` | Broken Telegram ‚Üí fallback to Discord |
| `SafeMode-E2E-Test` | E2E health check with safe mode |

---

## Scripts Reference

### Libraries (`/usr/local/sbin/`)

| Script | Purpose |
|--------|---------|
| `lib-env.sh` | Base64 decode (`d()`), env loading, API key decoding |
| `lib-auth.sh` | Token validation, auth headers, provider discovery, token hunting |
| `lib-health-check.sh` | Shared health check utilities (logging, env, variables) |
| `lib-notify.sh` | Notification library (Telegram/Discord), SafeModeBot intro |
| `lib-permissions.sh` | Centralized permission utilities |

### Executables (`/usr/local/bin/`)

| Script | Purpose |
|--------|---------|
| `generate-config.sh` | Unified jq-based config generator (full/session/safe-mode) |
| `gateway-health-check.sh` | HTTP-only health check (ExecStartPost, ~103 lines) |
| `gateway-e2e-check.sh` | E2E agent verification + intros (separate service, ~340 lines) |
| `safe-mode-handler.sh` | Recovery, notification, restart (triggered by .path, ~270 lines) |
| `safe-mode-recovery.sh` | Smart credential discovery (~987 lines) |
| `build-full-config.sh` | Orchestrator: calls generate-config, setup workspaces, generate systemd units |
| `generate-session-services.sh` | Creates per-group systemd units (session mode) |
| `generate-docker-compose.sh` | Creates per-group containers (container mode) |
| `collect-debug-logs.sh` | Collects full debug bundle |
| `rename-bots.sh` | Renames bot usernames on Telegram |
| `generate-boot-report.sh` | Creates diagnostic report for SafeModeBot |
| `setup-safe-mode-workspace.sh` | Creates SafeModeBot workspace and identity |

### Provisioning (`/usr/local/sbin/`)

| Script | Purpose |
|--------|---------|
| `provision.sh` | **Single-phase provisioning** (9 stages, sequential, ends with reboot) |
| `phase1-critical.sh` | Legacy: creates initial configs, enables bootstrap service |
| `phase2-background.sh` | Legacy: installs packages, calls build-full-config, reboots |
| `bootstrap.sh` | Entry point: auto-detects `provision.sh` vs legacy path |

### Library Dependency Graph

```
lib-env.sh                    ‚Üê standalone
  ‚Üë
lib-auth.sh                   ‚Üê sources lib-env.sh
  ‚Üë
lib-notify.sh                 ‚Üê sources lib-auth.sh
  ‚Üë
lib-health-check.sh           ‚Üê sources lib-env.sh

gateway-health-check.sh       ‚Üê sources lib-health-check, lib-env
gateway-e2e-check.sh          ‚Üê sources lib-health-check, lib-notify, lib-auth
safe-mode-handler.sh          ‚Üê sources lib-health-check, lib-notify
safe-mode-recovery.sh         ‚Üê sources lib-auth (via handler)
generate-config.sh            ‚Üê sources lib-env
```
