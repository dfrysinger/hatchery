#cloud-config
# version: 3.17

# Droplet Init Config v3.17 - 2026-02-04
# FAST BOOT: Bot online in ~3 min, desktop ready in background
# Phase 1: nodejs + clawdbot + minimal config -> bot talks
# Phase 2: packages, desktop, xrdp, skills (background)
#
# v3.17 Changes (from v3.16):
# - FIX: Post-boot health check timing too aggressive for 4-agent startup;
#         increased sleep-after-restart from 10s to 45s, health timeout from
#         10s to 30s, retry wait from 5s to 15s (no rush after phase1)
# - FIX: try-full-config.sh same timing improvements as post-boot-check
# - FIX: ExecStop sync failed with permission denied on /etc/droplet.env;
#         use systemd '+' prefix to run sync as root on service stop
# - FIX: BOOT.md missing message tool instructions and NO_REPLY guidance
# - FIX: Missing ~/.clawdbot/credentials dir (doctor flagged on every boot)
# - FIX: IDENTITY.md version reference updated to v3.17
# - ADD: vdirsyncer/khal calendar configuration (restored from v2.x)
# - FIX: TOOLS.md updated: himalaya replaced with gmail-api.py for email
# - FIX: gmail-api.py reads ~/.clawdbot/.env (bot-readable) before /etc/droplet.env
# - FIX: Gmail creds written to ~/.clawdbot/.env in phase1 and build-full-config
#
# v3.16 Changes (from v3.15):
# - FIX: pip --break-system-packages flag unsupported on Ubuntu 22.04 pip 22.x;
#         use PIP_BREAK_SYSTEM_PACKAGES=1 env var instead
# - FIX: bootcmd xrdp mask guard checks phase2-complete instead of setup-complete,
#         preventing xrdp from being re-masked on the phase2->reboot transition
#
# v3.15 Changes (from v3.14):
# - RENAME: Package openclaw -> clawdbot, binary openclaw -> clawdbot
# - RENAME: Dirs ~/openclaw -> ~/clawd, ~/.openclaw -> ~/.clawdbot
# - RENAME: Config openclaw.json -> clawdbot.json (.full.json, .minimal.json)
# - RENAME: Service openclaw.service -> clawdbot.service
# - RENAME: Timer openclaw-sync -> clawdbot-sync
# - RENAME: Scripts sync-openclaw-state.sh -> sync-clawdbot-state.sh,
#           restore-openclaw-state.sh -> restore-clawdbot-state.sh
# - RENAME: Dropbox path openclaw-memory -> clawdbot-memory
# - FIX: NODE_OPTIONS=--experimental-sqlite in both phase1 and full service
# - FIX: HEARTBEAT.md symlink uses -sf, created after clawdbot init (race fix)
# - FIX: xrdp daemon-reload after unmask before enable
# - FIX: Removed unused AGENT_GEN_B64 from droplet.env (leftover from v2.x)
# - NEW: IDENTITY.md includes Project Context section
# - NEW: Transcript syncing (sessions/*.jsonl) in sync/restore scripts
# - KEPT: All v3.14 fixes (binary path, heartbeat, setup-complete, sqlite,
#          tg-notify, SOUL, plugins, hooks, dmPolicy, multi-agent, safe mode)
#
# === PLACEHOLDER REFERENCE ===
# All placeholders use [[NAME]] format, replaced by iOS Shortcuts
# Base64 encoded: All _B64 suffix variables
#
# === NOTE: HEARTBEAT.md RACE CONDITION ===
# HEARTBEAT.md symlink must be created AFTER clawdbot creates agent workspace
# dirs (on first run). Phase 1 creates it for agent1 explicitly. build-full-config
# re-creates it with -sf for all agents after dirs exist. If clawdbot has not yet
# initialized the workspace, the symlink target dir may not exist - hence -sf.

package_update: false
package_upgrade: false

bootcmd:
  - [ bash, -lc, "mkdir -p /var/lib/init-status; [ -f /var/lib/init-status/setup-complete ] && exit 0; echo '0' > /var/lib/init-status/stage; echo '1' > /var/lib/init-status/phase; echo \"$(date -u +%Y-%m-%dT%H:%M:%SZ) STAGE=0 PHASE=1 DESC=init\" >> /var/log/init-stages.log" ]
  - [ bash, -lc, "[ -f /var/lib/init-status/setup-complete ] && exit 0; systemctl stop apt-daily.timer apt-daily-upgrade.timer apt-daily.service apt-daily-upgrade.service unattended-upgrades 2>/dev/null || true; systemctl disable apt-daily.timer apt-daily-upgrade.timer 2>/dev/null || true; killall -9 unattended-upgr apt apt-get dpkg 2>/dev/null || true" ]
  - [ bash, -lc, "[ -f /var/lib/init-status/phase2-complete ] && exit 0; systemctl stop xrdp xrdp-sesman 2>/dev/null || true; systemctl mask xrdp xrdp-sesman 2>/dev/null || true" ]
  # needrestart config handled by write_files section
  - [ bash, -lc, "[ -f /var/lib/init-status/setup-complete ] && exit 0; mkdir -p /tmp/downloads; curl -sL https://nodejs.org/dist/v22.12.0/node-v22.12.0-linux-x64.tar.xz -o /tmp/downloads/node.tar.xz & echo $! > /tmp/downloads/node.pid; wget -q -O /tmp/downloads/chrome.deb https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb & echo $! > /tmp/downloads/chrome.pid" ]
  - [ bash, -lc, "[ -f /var/lib/init-status/setup-complete ] && [ ! -f /var/lib/init-status/boot-complete ] && { echo '99' > /var/lib/init-status/stage; echo \"$(date -u +%Y-%m-%dT%H:%M:%SZ) STAGE=99 DESC=ready\" >> /var/log/init-stages.log; touch /var/lib/init-status/boot-complete; } || true" ]

write_files:
  - path: /etc/droplet.env
    owner: root:root
    permissions: "0600"
    content: |
      USERNAME="bot"
      SSH_KEY_B64=""
      DO_TOKEN_B64="[[DO_TOKEN_B64]]"
      PASSWORD_B64="[[PASSWORD_B64]]"
      DESTRUCT_MINS_B64="[[DESTRUCT_MINS_B64]]"
      AGENT1_BOT_TOKEN_B64="[[AGENT1_BOT_TOKEN_B64]]"
      TELEGRAM_USER_ID_B64="[[TELEGRAM_USER_ID_B64]]"
      ANTHROPIC_KEY_B64="[[ANTHROPIC_KEY_B64]]"
      BRAVE_KEY_B64="[[BRAVE_KEY_B64]]"
      GOOGLE_API_KEY_B64="[[GOOGLE_API_KEY_B64]]"
      DROPBOX_TOKEN_B64="[[DROPBOX_TOKEN_B64]]"
      EMAIL_B64="[[EMAIL_B64]]"
      IMAP_HOST_B64="[[IMAP_HOST_B64]]"
      SMTP_HOST_B64="[[SMTP_HOST_B64]]"
      EMAIL_PASSWORD_B64="[[EMAIL_PASSWORD_B64]]"
      CALDAV_URL_B64="[[CALDAV_URL_B64]]"
      CALDAV_USER_B64="[[CALDAV_USER_B64]]"
      CALDAV_PASSWORD_B64="[[CALDAV_PASSWORD_B64]]"
      GH_TOKEN_B64="[[GH_TOKEN_B64]]"
      GMAIL_CLIENT_ID_B64="[[GMAIL_CLIENT_ID_B64]]"
      GMAIL_CLIENT_SECRET_B64="[[GMAIL_CLIENT_SECRET_B64]]"
      GMAIL_REFRESH_TOKEN_B64="[[GMAIL_REFRESH_TOKEN_B64]]"
      USER_REALNAME_B64="[[USER_REALNAME_B64]]"
      USER_LOCATION_B64="[[USER_LOCATION_B64]]"
      USER_NOTES_B64="[[USER_NOTES_B64]]"
      BOOT_INSTRUCTIONS_B64="[[BOOT_INSTRUCTIONS_B64]]"
      HABITAT_NAME_B64="[[HABITAT_NAME_B64]]"
      OPENAI_ACCESS_B64="[[OPENAI_ACCESS_B64]]"
      OPENAI_REFRESH_B64="[[OPENAI_REFRESH_B64]]"
      OPENAI_EXPIRES_B64="[[OPENAI_EXPIRES_B64]]"
      OPENAI_ACCOUNT_ID_B64="[[OPENAI_ACCOUNT_ID_B64]]"
      GLOBAL_AGENT_NOTES_B64="[[GLOBAL_AGENT_NOTES_B64]]"
      AGENT1_NAME_B64="[[AGENT1_NAME_B64]]"
      AGENT1_NOTES_B64="[[AGENT1_NOTES_B64]]"
      AGENT1_SOUL_B64="[[AGENT1_SOUL_B64]]"
      AGENT2_NAME_B64="[[AGENT2_NAME_B64]]"
      AGENT2_NOTES_B64="[[AGENT2_NOTES_B64]]"
      AGENT2_SOUL_B64="[[AGENT2_SOUL_B64]]"
      AGENT2_BOT_TOKEN_B64="[[AGENT2_BOT_TOKEN_B64]]"
      AGENT3_NAME_B64="[[AGENT3_NAME_B64]]"
      AGENT3_NOTES_B64="[[AGENT3_NOTES_B64]]"
      AGENT3_SOUL_B64="[[AGENT3_SOUL_B64]]"
      AGENT3_BOT_TOKEN_B64="[[AGENT3_BOT_TOKEN_B64]]"
      AGENT4_NAME_B64="[[AGENT4_NAME_B64]]"
      AGENT4_NOTES_B64="[[AGENT4_NOTES_B64]]"
      AGENT4_SOUL_B64="[[AGENT4_SOUL_B64]]"
      AGENT4_BOT_TOKEN_B64="[[AGENT4_BOT_TOKEN_B64]]"
      COUNCIL_GROUP_ID_B64="[[COUNCIL_GROUP_ID_B64]]"

  - path: /etc/needrestart/conf.d/99-autorestart.conf
    permissions: "0644"
    content: |
      $nrconf{restart} = 'a';
      $nrconf{blacklist_rc} = [qr/^cloud-init/, qr/^cloud-final/, qr/^cloud-config/];

  - path: /usr/local/bin/set-stage.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      echo "$1" > /var/lib/init-status/stage
      echo "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ) STAGE=$1 PHASE=$(cat /var/lib/init-status/phase 2>/dev/null || echo 1) DESC=$2" >> /var/log/init-stages.log

  - path: /usr/local/bin/set-phase.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      echo "$1" > /var/lib/init-status/phase
      echo "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ) PHASE=$1 DESC=$2" >> /var/log/init-stages.log

  - path: /usr/local/bin/tg-notify.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Send Telegram notification - used for early status messages
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      TBT=$(d "$AGENT1_BOT_TOKEN_B64")
      TUI=$(d "$TELEGRAM_USER_ID_B64")
      [ -z "$TBT" ] || [ -z "$TUI" ] && exit 1
      MSG="$1"
      curl -sf --max-time 10 "https://api.telegram.org/bot${TBT}/sendMessage" \
        -d "chat_id=${TUI}" \
        -d "text=${MSG}" > /dev/null 2>&1

  - path: /etc/systemd/system/api-server.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Droplet Status API
      After=network.target
      [Service]
      ExecStart=/usr/local/bin/api-server.py
      Restart=always
      RestartSec=3
      User=root
      [Install]
      WantedBy=multi-user.target

  - path: /usr/local/bin/api-server.py
    permissions: "0755"
    content: |
      #!/usr/bin/env python3
      import http.server,socketserver,subprocess,json,os,base64
      PORT=8080
      P1_STAGES={0:"init",1:"nodejs",2:"clawdbot-install",3:"config",4:"starting",5:"bot-online"}
      P2_STAGES={10:"packages",11:"chrome",12:"pip",13:"desktop",14:"skills",15:"productivity",16:"xrdp",17:"finalize",18:"reboot",99:"ready"}
      def check_service(name):
        try:r=subprocess.run(["systemctl","is-active",name],capture_output=True,timeout=5);return r.stdout.decode().strip()=="active"
        except:return False
      def get_status():
        s,p=0,1
        try:
          with open('/var/lib/init-status/stage','r') as f:s=int(f.read().strip())
          with open('/var/lib/init-status/phase','r') as f:p=int(f.read().strip())
        except:pass
        p1_done=os.path.exists('/var/lib/init-status/phase1-complete')
        p2_done=os.path.exists('/var/lib/init-status/phase2-complete')
        setup_done=os.path.exists('/var/lib/init-status/setup-complete')
        bot_online=check_service('clawdbot')
        svc={}
        if p2_done or setup_done:
          for sv in ['clawdbot','xrdp','desktop','x11vnc']:svc[sv]=check_service(sv)
        desc=P1_STAGES.get(s) if p==1 else P2_STAGES.get(s,f"stage-{s}")
        safe_mode=os.path.exists('/var/lib/init-status/safe-mode')
        return {"phase":p,"stage":s,"desc":desc,"bot_online":bot_online,"phase1_complete":p1_done,"phase2_complete":p2_done,"ready":setup_done and bot_online,"safe_mode":safe_mode,"services":svc if svc else None}
      class H(http.server.BaseHTTPRequestHandler):
        def log_message(self,*a):pass
        def do_GET(self):
          if self.path=='/status':
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers();self.wfile.write(json.dumps(get_status()).encode())
          elif self.path=='/health':
            s=get_status();code=200 if s.get('bot_online') else 503;self.send_response(code);self.send_header('Content-type','application/json');self.end_headers();self.wfile.write(json.dumps({"healthy":s.get('bot_online',False),"phase":s.get('phase'),"desc":s.get('desc'),"safe_mode":s.get('safe_mode',False)}).encode())
          elif self.path=='/stages':
            self.send_response(200);self.send_header('Content-type','text/plain');self.end_headers()
            try:
              with open('/var/log/init-stages.log','r') as f:self.wfile.write(f.read().encode())
            except:self.wfile.write(b"No log")
          else:self.send_response(404);self.end_headers()
        def do_POST(self):
          if self.path=='/sync':
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers()
            try:r=subprocess.run("/usr/local/bin/sync-clawdbot-state.sh",shell=True,capture_output=True,timeout=60);self.wfile.write(json.dumps({"ok":r.returncode==0}).encode())
            except Exception as x:self.wfile.write(json.dumps({"ok":False,"error":str(x)}).encode())
          elif self.path=='/prepare-shutdown':
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers()
            try:subprocess.run("/usr/local/bin/sync-clawdbot-state.sh",shell=True,timeout=60);subprocess.run("systemctl stop clawdbot",shell=True,timeout=30);self.wfile.write(json.dumps({"ok":True,"ready_for_shutdown":True}).encode())
            except Exception as x:self.wfile.write(json.dumps({"ok":False,"error":str(x)}).encode())
          else:self.send_response(404);self.end_headers()
      class R(socketserver.TCPServer):allow_reuse_address=True
      with R(("",PORT),H) as h:h.serve_forever()

  - path: /usr/local/sbin/phase1-critical.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # PHASE 1: Get bot online ASAP (~3 min target)
      # Minimal bulletproof config - single agent, telegram only
      set -e
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      S="/usr/local/bin/set-stage.sh"
      TG="/usr/local/bin/tg-notify.sh"
      LOG="/var/log/phase1.log"
      echo "=== Phase 1 Start: $(date) ===" > "$LOG"
      START=$(date +%s)

      # Send early notification
      $TG "[INIT] Droplet starting up. Phase 1 in progress..."

      # Wait for node download (started in bootcmd)
      $S 1 "nodejs"
      NODE_PID=$(cat /tmp/downloads/node.pid 2>/dev/null)
      [ -n "$NODE_PID" ] && wait $NODE_PID 2>/dev/null || true

      # Extract node binary
      if [ -f /tmp/downloads/node.tar.xz ]; then
        tar -xJf /tmp/downloads/node.tar.xz -C /usr/local --strip-components=1 >> "$LOG" 2>&1
        rm -f /tmp/downloads/node.tar.xz
        echo "Node installed: $(node --version)" >> "$LOG"
      else
        echo "ERROR: Node download failed, falling back to apt" >> "$LOG"
        apt-get update -qq && apt-get install -y nodejs npm >> "$LOG" 2>&1
      fi

      # Install clawdbot
      $S 2 "clawdbot-install"
      npm install -g clawdbot@latest >> "$LOG" 2>&1
      echo "Clawdbot installed: $(clawdbot --version 2>/dev/null || echo 'unknown')" >> "$LOG"

      # Setup user (minimal)
      $S 3 "config"
      PW=$(d "$PASSWORD_B64")
      id "$USERNAME" &>/dev/null || useradd -m -s /bin/bash -G sudo "$USERNAME"
      echo "$USERNAME:$PW" | chpasswd
      echo "$USERNAME ALL=(ALL) NOPASSWD:ALL" > /etc/sudoers.d/$USERNAME

      # Decode credentials
      AK=$(d "$ANTHROPIC_KEY_B64")
      TBT=$(d "$AGENT1_BOT_TOKEN_B64")
      TUI=$(d "$TELEGRAM_USER_ID_B64")
      GK=$(d "$GOOGLE_API_KEY_B64")
      A1N=$(d "$AGENT1_NAME_B64"); A1N="${A1N:-Claude}"
      H="/home/$USERNAME"
      GT=$(openssl rand -hex 24)

      mkdir -p $H/.clawdbot $H/clawd/agents/agent1/memory
      echo "$GT" > $H/.clawdbot/gateway-token.txt

      # Symlink HEARTBEAT.md to agent1 workspace (critical for safe-mode detection)
      # NOTE: Uses -sf to force overwrite; target dir created above
      ln -sf "$H/clawd/HEARTBEAT.md" "$H/clawd/agents/agent1/HEARTBEAT.md"

      # MINIMAL CONFIG - bulletproof, single agent, telegram only
      # No browser, no skills, no hooks - just enough to talk
      cat > $H/.clawdbot/clawdbot.json <<CFG
      {
        "env": {
          "ANTHROPIC_API_KEY": "${AK}"
        },
        "agents": {
          "defaults": {
            "model": {"primary": "anthropic/claude-sonnet-4-20250514"},
            "workspace": "$H/clawd"
          },
          "list": [
            {
              "id": "agent1",
              "default": true,
              "name": "${A1N}",
              "workspace": "$H/clawd/agents/agent1"
            }
          ]
        },
        "gateway": {
          "mode": "local",
          "port": 18789,
          "bind": "lan",
          "auth": {
            "mode": "token",
            "token": "${GT}"
          }
        },
        "plugins": {
          "entries": {
            "telegram": {"enabled": true}
          }
        },
        "channels": {
          "telegram": {
            "enabled": true,
            "dmPolicy": "allowlist",
            "allowFrom": ["${TUI}"],
            "accounts": {
              "default": {"botToken": "${TBT}"}
            }
          }
        }
      }
      CFG

      # Save minimal config as fallback
      cp $H/.clawdbot/clawdbot.json $H/.clawdbot/clawdbot.minimal.json

      # Create .env file (used by gmail-api.py and other tools that need creds)
      echo "ANTHROPIC_API_KEY=${AK}" > $H/.clawdbot/.env
      [ -n "$GK" ] && echo -e "GOOGLE_API_KEY=${GK}\nGEMINI_API_KEY=${GK}" >> $H/.clawdbot/.env
      GCID=$(d "$GMAIL_CLIENT_ID_B64"); GSEC=$(d "$GMAIL_CLIENT_SECRET_B64"); GRTK=$(d "$GMAIL_REFRESH_TOKEN_B64")
      [ -n "$GCID" ] && echo -e "GMAIL_CLIENT_ID=${GCID}\nGMAIL_CLIENT_SECRET=${GSEC}\nGMAIL_REFRESH_TOKEN=${GRTK}" >> $H/.clawdbot/.env

      # Create minimal AGENTS.md
      echo -e "# Agent: ${A1N}\nModel: Claude Sonnet\nBe helpful. Desktop setup in progress..." > $H/clawd/agents/agent1/AGENTS.md

      # Create BOOT.md for self-announcement
      cat > $H/clawd/agents/agent1/BOOT.md <<'BOOTMD'
      # BOOT.md - Runs Every Heartbeat

      ## On Fresh Boot
      If this is your first message since the system started, announce yourself:
      "[ONLINE] Ready and operational."

      If you see a file called SAFE_MODE.md in your workspace, read and follow it.

      ## Health Monitoring
      Check these services silently. Only alert user if something is broken after 2 fix attempts:
      - systemctl is-active clawdbot
      - systemctl is-active xrdp (if desktop phase complete)
      - systemctl is-active desktop (if desktop phase complete)

      ## Self-Healing Permission
      You have standing authority to fix infrastructure issues WITHOUT user approval:
      - Restart services: sudo systemctl restart <service>
      - Check logs: journalctl -u <service> -n 50
      - Fix permissions: sudo chown -R bot:bot /home/bot
      - Reinstall packages if needed
      - Reboot if necessary: sudo reboot

      Always inform the user what you did and the outcome.

      ## During Setup
      If /var/lib/init-status/phase2-complete does not exist, desktop is still installing.
      Tell user: "Desktop setup in progress. RDP will be ready soon."

      If BOOT.md asks you to send a message, use the message tool (action=send with channel + target).
      Use the `target` field (not `to`) for message tool destinations.
      After sending with the message tool, reply with ONLY: NO_REPLY.
      If nothing needs attention, reply with ONLY: NO_REPLY.
      BOOTMD

      chown -R $USERNAME:$USERNAME $H/.clawdbot $H/clawd
      chmod 700 $H/.clawdbot
      chmod 600 $H/.clawdbot/clawdbot.json

      # Systemd service (phase 1 minimal - includes NODE_OPTIONS for sqlite)
      cat > /etc/systemd/system/clawdbot.service <<SVC
      [Unit]
      Description=Clawdbot Gateway
      After=network.target
      [Service]
      Type=simple
      User=$USERNAME
      WorkingDirectory=$H
      ExecStart=/usr/local/bin/clawdbot gateway --bind lan --port 18789
      Restart=always
      RestartSec=3
      Environment=NODE_ENV=production
      Environment=NODE_OPTIONS=--experimental-sqlite
      Environment=ANTHROPIC_API_KEY=${AK}
      $([ -n "$GK" ] && echo "Environment=GOOGLE_API_KEY=${GK}")
      $([ -n "$GK" ] && echo "Environment=GEMINI_API_KEY=${GK}")
      [Install]
      WantedBy=multi-user.target
      SVC

      # Start bot
      $S 4 "starting"
      systemctl daemon-reload
      systemctl enable clawdbot
      systemctl start clawdbot
      ufw allow 18789/tcp

      # Wait for bot to be ready
      BOT_OK=false
      for i in {1..30}; do
        if systemctl is-active --quiet clawdbot; then
          BOT_OK=true
          break
        fi
        sleep 1
      done

      if [ "$BOT_OK" = "true" ]; then
        $S 5 "bot-online"
        $TG "[OK] Bot online! Phase 1 complete. Starting desktop setup..."
      else
        echo "WARNING: Bot failed to start" >> "$LOG"
        journalctl -u clawdbot -n 50 >> "$LOG" 2>&1
        $TG "[WARN] Bot may not be running. Check logs: journalctl -u clawdbot"
      fi

      touch /var/lib/init-status/phase1-complete
      echo "$START" > /var/lib/init-status/phase1-time

      END=$(date +%s)
      echo "=== Phase 1 Complete: $((END - START)) seconds ===" >> "$LOG"

      # Kick off phase 2 in background
      /usr/local/bin/set-phase.sh 2 "background-setup"
      nohup /usr/local/sbin/phase2-background.sh >> /var/log/phase2.log 2>&1 &
      disown

  - path: /usr/local/sbin/phase2-background.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # PHASE 2: Everything else (runs in background)
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      S="/usr/local/bin/set-stage.sh"
      LOG="/var/log/phase2.log"
      echo "=== Phase 2 Start: $(date) ===" >> "$LOG"
      START=$(date +%s)
      H="/home/$USERNAME"

      # Wait for chrome download
      CHROME_PID=$(cat /tmp/downloads/chrome.pid 2>/dev/null)
      [ -n "$CHROME_PID" ] && wait $CHROME_PID 2>/dev/null || true

      # Kill apt locks
      systemctl stop apt-daily.timer apt-daily-upgrade.timer 2>/dev/null || true
      killall -9 apt apt-get dpkg 2>/dev/null || true
      sleep 2
      rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock /var/lib/apt/lists/lock
      dpkg --configure -a 2>/dev/null || true

      # Full package install
      $S 10 "packages"
      apt-get update -qq >> "$LOG" 2>&1
      DEBIAN_FRONTEND=noninteractive NEEDRESTART_MODE=a apt-get install -y --no-install-recommends \
        xrdp xorgxrdp xvfb x11vnc lightdm dbus-x11 xserver-xorg-video-dummy \
        xfce4 xfce4-goodies xfce4-terminal \
        build-essential git gh ffmpeg imagemagick vlc libreoffice-writer \
        thunderbird pandoc scrot flameshot qpdf jq htop ncdu bc wget xz-utils \
        python3 python3-pip rclone fuse3 khal vdirsyncer unattended-upgrades \
        >> "$LOG" 2>&1

      # Remove screensaver BEFORE starting desktop
      rm -f /etc/xdg/autostart/xfce4-screensaver.desktop
      apt-get purge -y xfce4-screensaver gnome-keyring libpam-gnome-keyring seahorse 2>/dev/null || true

      # Install chrome
      $S 11 "chrome"
      [ -f /tmp/downloads/chrome.deb ] && dpkg -i /tmp/downloads/chrome.deb >> "$LOG" 2>&1
      rm -f /tmp/downloads/chrome.deb
      apt-get -f install -y >> "$LOG" 2>&1

      # Chrome config
      mkdir -p $H/.config/chrome-debug/Default
      echo '{"browser":{"default_browser_infobar_last_declined":"99999999999999.0","default_browser_setting_enabled":false}}' > "$H/.config/chrome-debug/Local State"
      echo '{"browser":{"check_default_browser":false},"session":{"restore_on_startup":1},"distribution":{"skip_first_run_ui":true,"suppress_first_run_default_browser_prompt":true}}' > "$H/.config/chrome-debug/Default/Preferences"
      touch "$H/.config/chrome-debug/First Run"
      chown -R $USERNAME:$USERNAME $H/.config/chrome-debug

      # Pip packages
      $S 12 "pip"
      PIP_BREAK_SYSTEM_PACKAGES=1 pip3 install -U yt-dlp google-auth google-api-python-client >> "$LOG" 2>&1
      curl -sSL https://raw.githubusercontent.com/pimalaya/himalaya/master/install.sh | sh >> "$LOG" 2>&1
      [ -f /root/.local/bin/himalaya ] && ln -sf /root/.local/bin/himalaya /usr/local/bin/himalaya

      # Desktop services
      $S 13 "desktop"
      cat > /etc/systemd/system/xvfb.service <<SVC
      [Unit]
      Description=Xvfb on :10
      After=network.target
      [Service]
      Type=simple
      User=$USERNAME
      ExecStart=/usr/bin/Xvfb :10 -screen 0 1920x1080x24 -ac
      Restart=always
      [Install]
      WantedBy=multi-user.target
      SVC

      cat > /etc/systemd/system/desktop.service <<SVC
      [Unit]
      Description=XFCE Desktop
      After=xvfb.service
      Requires=xvfb.service
      [Service]
      Type=simple
      User=$USERNAME
      Environment=DISPLAY=:10
      Environment=HOME=$H
      Environment=DBUS_SESSION_BUS_ADDRESS=autolaunch:
      ExecStartPre=/bin/sleep 2
      ExecStart=/usr/bin/xfce4-session
      Restart=on-failure
      [Install]
      WantedBy=multi-user.target
      SVC

      cat > /etc/systemd/system/x11vnc.service <<SVC
      [Unit]
      Description=x11vnc
      After=desktop.service
      Requires=desktop.service
      [Service]
      Type=simple
      User=$USERNAME
      Environment=DISPLAY=:10
      ExecStartPre=/bin/sleep 3
      ExecStart=/usr/bin/x11vnc -display :10 -rfbport 5900 -forever -nopw -shared -localhost
      Restart=on-failure
      [Install]
      WantedBy=multi-user.target
      SVC

      mkdir -p $H/.config/xfce4/xfconf/xfce-perchannel-xml
      chown -R $USERNAME:$USERNAME $H/.config

      systemctl daemon-reload
      systemctl enable xvfb desktop x11vnc
      systemctl start xvfb
      sleep 2
      systemctl start desktop
      sleep 3
      systemctl start x11vnc

      # Desktop shortcuts
      mkdir -p $H/Desktop
      cat > $H/Desktop/google-chrome.desktop <<'DESK'
      [Desktop Entry]
      Version=1.0
      Name=Google Chrome
      Exec=/usr/bin/google-chrome-stable --password-store=basic --no-first-run --no-default-browser-check --disable-sync --remote-debugging-port=18800 --user-data-dir=/home/bot/.config/chrome-debug %U
      Terminal=false
      Icon=google-chrome
      Type=Application
      DESK
      cat > $H/Desktop/dropbox.desktop <<'DESK'
      [Desktop Entry]
      Version=1.0
      Type=Application
      Name=Mount Dropbox
      Exec=/usr/local/bin/mount-dropbox.sh
      Icon=folder-remote
      Terminal=false
      DESK
      chmod +x $H/Desktop/*.desktop
      chown -R $USERNAME:$USERNAME $H/Desktop

      # Skills
      $S 14 "skills"
      npm install -g clawhub@latest >> "$LOG" 2>&1
      for s in weather github video-frames goplaces youtube-transcript yt-dlp-downloader-skill; do
        su - $USERNAME -c "cd $H/clawd && clawhub install $s" >> "$LOG" 2>&1 || true
      done
      find $H/clawd/skills -name "*.sh" -exec chmod +x {} \; 2>/dev/null || true

      # Productivity (rclone, himalaya, calendar)
      $S 15 "productivity"
      DBT=$(d "$DROPBOX_TOKEN_B64"); EM=$(d "$EMAIL_B64"); EP=$(d "$EMAIL_PASSWORD_B64")
      IH=$(d "$IMAP_HOST_B64"); GHT=$(d "$GH_TOKEN_B64")
      mkdir -p $H/.config/{himalaya,rclone,gh}
      [ -n "$DBT" ] && echo -e "[dropbox]\ntype = dropbox\ntoken = $DBT" > $H/.config/rclone/rclone.conf
      [ -n "$EM" ] && [ -n "$EP" ] && cat > $H/.config/himalaya/config.toml <<HIM
      [accounts.default]
      email = "${EM}"
      default = true
      backend.type = "imap"
      backend.host = "${IH:-imap.gmail.com}"
      backend.port = 993
      backend.encryption.type = "tls"
      backend.login = "${EM}"
      backend.auth.type = "password"
      backend.auth.raw = "${EP}"
      HIM
      [ -n "$GHT" ] && echo -e "github.com:\n    oauth_token: ${GHT}\n    git_protocol: https" > $H/.config/gh/hosts.yml

      # Calendar (vdirsyncer + khal)
      CU=$(d "$CALDAV_URL_B64"); CUN=$(d "$CALDAV_USER_B64"); CP=$(d "$CALDAV_PASSWORD_B64")
      if [ -n "$CU" ] && [ -n "$CUN" ]; then
        mkdir -p $H/.config/vdirsyncer $H/.config/khal
        mkdir -p $H/.local/share/vdirsyncer/status $H/.local/share/khal/calendars
        cat > $H/.config/vdirsyncer/config <<VDSCFG
      [general]
      status_path = "~/.local/share/vdirsyncer/status/"

      [pair calendar]
      a = "calendar_local"
      b = "calendar_remote"
      collections = ["from a", "from b"]
      metadata = ["color"]

      [storage calendar_local]
      type = "filesystem"
      path = "~/.local/share/khal/calendars/"
      fileext = ".ics"

      [storage calendar_remote]
      type = "caldav"
      url = "${CU}"
      username = "${CUN}"
      password = "${CP}"
      VDSCFG
        cat > $H/.config/khal/config <<KHALCFG
      [calendars]

      [[default]]
      path = ~/.local/share/khal/calendars/*
      type = discover

      [locale]
      timeformat = %H:%M
      dateformat = %Y-%m-%d
      longdateformat = %Y-%m-%d
      datetimeformat = %Y-%m-%d %H:%M
      longdatetimeformat = %Y-%m-%d %H:%M
      KHALCFG
        chown -R $USERNAME:$USERNAME $H/.config/vdirsyncer $H/.config/khal $H/.local/share/vdirsyncer $H/.local/share/khal
        su - $USERNAME -c "yes | vdirsyncer discover" >> "$LOG" 2>&1 || true
        su - $USERNAME -c "vdirsyncer sync" >> "$LOG" 2>&1 || true
        echo "Calendar configured (vdirsyncer + khal)" >> "$LOG"
      fi

      chown -R $USERNAME:$USERNAME $H/.config

      # xrdp
      $S 16 "xrdp"
      cat > /etc/xrdp/xrdp.ini <<'XI'
      [Globals]
      ini_version=1
      fork=true
      port=3389
      tcp_nodelay=true
      security_layer=rdp
      crypt_level=high
      max_bpp=32
      [Logging]
      LogFile=xrdp.log
      LogLevel=INFO
      [Channels]
      rdpdr=true
      rdpsnd=true
      cliprdr=true
      [vnc-any]
      name=Desktop
      lib=libvnc.so
      ip=127.0.0.1
      port=5900
      username=na
      password=ask
      XI
      echo -e "#!/bin/sh\nexec sleep infinity" > /etc/xrdp/startwm.sh
      chmod 755 /etc/xrdp/startwm.sh
      systemctl unmask xrdp xrdp-sesman
      systemctl daemon-reload
      systemctl enable xrdp
      systemctl restart xrdp
      ufw allow 3389/tcp

      # Restore state from Dropbox BEFORE build-full-config
      # so YAML-generated files always take precedence
      $S 17 "finalize"
      /usr/local/bin/restore-clawdbot-state.sh 2>/dev/null || true

      # Build and save full config (overwrites YAML-owned files after restore)
      /usr/local/sbin/build-full-config.sh

      # Enable auto-upgrades and sync timer
      systemctl enable unattended-upgrades apt-daily.timer apt-daily-upgrade.timer
      systemctl enable clawdbot-sync.timer 2>/dev/null || true
      systemctl start clawdbot-sync.timer 2>/dev/null || true

      touch /var/lib/init-status/phase2-complete
      touch /var/lib/init-status/needs-post-boot-check

      END=$(date +%s)
      DURATION=$((END - START))
      echo "=== Phase 2 Complete: ${DURATION} seconds ===" >> "$LOG"

      # Announce reboot via Telegram
      TG="/usr/local/bin/tg-notify.sh"
      $TG "[SETUP COMPLETE] Desktop ready. Phase 2 finished in ${DURATION}s. Rebooting for clean state... Back shortly!"

      sleep 5
      $S 18 "reboot"
      reboot

  - path: /usr/local/sbin/build-full-config.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Build full clawdbot config with all features
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      H="/home/$USERNAME"

      AK=$(d "$ANTHROPIC_KEY_B64"); GK=$(d "$GOOGLE_API_KEY_B64"); BK=$(d "$BRAVE_KEY_B64")
      OA=$(d "$OPENAI_ACCESS_B64"); OR=$(d "$OPENAI_REFRESH_B64"); OE=$(d "$OPENAI_EXPIRES_B64"); OI=$(d "$OPENAI_ACCOUNT_ID_B64")
      TBT=$(d "$AGENT1_BOT_TOKEN_B64"); TUI=$(d "$TELEGRAM_USER_ID_B64")
      HN=$(d "$HABITAT_NAME_B64"); HN="${HN:-default}"

      # Agent names and notes
      GAN=$(d "$GLOBAL_AGENT_NOTES_B64")
      A1N=$(d "$AGENT1_NAME_B64"); A1N="${A1N:-Claude}"; A1NOTES=$(d "$AGENT1_NOTES_B64"); A1SOUL=$(d "$AGENT1_SOUL_B64")
      A2N=$(d "$AGENT2_NAME_B64"); A2N="${A2N:-GPT}"; A2T=$(d "$AGENT2_BOT_TOKEN_B64"); A2NOTES=$(d "$AGENT2_NOTES_B64"); A2SOUL=$(d "$AGENT2_SOUL_B64")
      A3N=$(d "$AGENT3_NAME_B64"); A3N="${A3N:-Gemini}"; A3T=$(d "$AGENT3_BOT_TOKEN_B64"); A3NOTES=$(d "$AGENT3_NOTES_B64"); A3SOUL=$(d "$AGENT3_SOUL_B64")
      A4N=$(d "$AGENT4_NAME_B64"); A4N="${A4N:-Opus}"; A4T=$(d "$AGENT4_BOT_TOKEN_B64"); A4NOTES=$(d "$AGENT4_NOTES_B64"); A4SOUL=$(d "$AGENT4_SOUL_B64")

      CGI=$(d "$COUNCIL_GROUP_ID_B64")
      URN=$(d "$USER_REALNAME_B64"); UL=$(d "$USER_LOCATION_B64"); UN=$(d "$USER_NOTES_B64")
      BI=$(d "$BOOT_INSTRUCTIONS_B64")
      GT=$(cat $H/.clawdbot/gateway-token.txt)

      # Create agent directories and credentials dir (doctor expects it)
      mkdir -p $H/.clawdbot/credentials
      mkdir -p $H/clawd/agents/agent1/memory
      [ -n "$A2T" ] && mkdir -p $H/clawd/agents/agent2/memory
      [ -n "$A3T" ] && mkdir -p $H/clawd/agents/agent3/memory
      [ -n "$A4T" ] && mkdir -p $H/clawd/agents/agent4/memory

      # Build agent list JSON
      AL="[{\"id\":\"agent1\",\"default\":true,\"name\":\"${A1N}\",\"model\":\"anthropic/claude-opus-4-5\",\"workspace\":\"$H/clawd/agents/agent1\",\"groupChat\":{\"mentionPatterns\":[\"${A1N},\",\"${A1N}:\"]}}"
      [ -n "$A2T" ] && AL="$AL,{\"id\":\"agent2\",\"name\":\"${A2N}\",\"model\":\"openai/gpt-5.2\",\"workspace\":\"$H/clawd/agents/agent2\",\"groupChat\":{\"mentionPatterns\":[\"${A2N},\",\"${A2N}:\"]}}"
      [ -n "$A3T" ] && AL="$AL,{\"id\":\"agent3\",\"name\":\"${A3N}\",\"model\":\"google/gemini-3-pro-preview\",\"workspace\":\"$H/clawd/agents/agent3\",\"groupChat\":{\"mentionPatterns\":[\"${A3N},\",\"${A3N}:\"]}}"
      [ -n "$A4T" ] && AL="$AL,{\"id\":\"agent4\",\"name\":\"${A4N}\",\"model\":\"anthropic/claude-opus-4-5\",\"workspace\":\"$H/clawd/agents/agent4\",\"groupChat\":{\"mentionPatterns\":[\"${A4N},\",\"${A4N}:\"]}}"
      AL="$AL]"

      # Bindings for multi-agent
      BD="["
      [ -n "$A2T" ] && BD="$BD{\"agentId\":\"agent2\",\"match\":{\"channel\":\"telegram\",\"accountId\":\"agent2\"}}"
      [ -n "$A3T" ] && { [ "$BD" != "[" ] && BD="$BD,"; BD="$BD{\"agentId\":\"agent3\",\"match\":{\"channel\":\"telegram\",\"accountId\":\"agent3\"}}"; }
      [ -n "$A4T" ] && { [ "$BD" != "[" ] && BD="$BD,"; BD="$BD{\"agentId\":\"agent4\",\"match\":{\"channel\":\"telegram\",\"accountId\":\"agent4\"}}"; }
      BD="$BD]"

      # Telegram accounts
      TA="\"default\":{\"botToken\":\"${TBT}\"}"
      [ -n "$A2T" ] && TA="$TA,\"agent2\":{\"botToken\":\"${A2T}\"}"
      [ -n "$A3T" ] && TA="$TA,\"agent3\":{\"botToken\":\"${A3T}\"}"
      [ -n "$A4T" ] && TA="$TA,\"agent4\":{\"botToken\":\"${A4T}\"}"

      TG=""; [ -n "$CGI" ] && TG=",\"groups\":{\"${CGI}\":{\"requireMention\":true},\"*\":{\"requireMention\":true}}"

      # Auth profiles
      AP="\"anthropic:default\":{\"provider\":\"anthropic\",\"mode\":\"api_key\"}"
      [ -n "$OA" ] && AP="$AP,\"openai-codex:default\":{\"provider\":\"openai-codex\",\"mode\":\"oauth\"}"
      [ -n "$GK" ] && AP="$AP,\"google:default\":{\"provider\":\"google\",\"mode\":\"api_key\"}"

      # Write full config
      cat > $H/.clawdbot/clawdbot.full.json <<CFG
      {
        "env": {
          "ANTHROPIC_API_KEY": "${AK}",
          "DISPLAY": ":10"
          $([ -n "$GK" ] && echo ",\"GOOGLE_API_KEY\": \"${GK}\", \"GEMINI_API_KEY\": \"${GK}\"")
          $([ -n "$BK" ] && echo ",\"BRAVE_API_KEY\": \"${BK}\"")
        },
        "browser": {
          "enabled": true,
          "executablePath": "/usr/bin/google-chrome-stable",
          "headless": false,
          "noSandbox": true
        },
        "agents": {
          "defaults": {
            "model": {"primary": "anthropic/claude-opus-4-5"},
            "maxConcurrent": 4,
            "workspace": "$H/clawd",
            "models": {
              "openai/gpt-5.2": {"params": {"reasoning_effort": "high"}}
            }
          },
          "list": ${AL}
        },
        "bindings": ${BD},
        "gateway": {
          "mode": "local",
          "port": 18789,
          "bind": "lan",
          "controlUi": {"enabled": true, "allowInsecureAuth": true},
          "auth": {"mode": "token", "token": "${GT}"}
        },
        "auth": {
          "profiles": {${AP}}
        },
        "plugins": {
          "entries": {
            "telegram": {"enabled": true}
          }
        },
        "channels": {
          "telegram": {
            "enabled": true,
            "dmPolicy": "allowlist",
            "allowFrom": ["${TUI}"],
            "accounts": {${TA}}
            ${TG}
          }
        },
        "skills": {
          "install": {"nodeManager": "npm"}
        },
        "hooks": {
          "internal": {
            "enabled": true,
            "entries": {
              "boot-md": {"enabled": true}
            }
          }
        }
      }
      CFG

      # Create IDENTITY.md for each agent (includes Project Context)
      write_identity() {
        local ADIR="$1" ANAME="$2" ANOTES="$3"
        cat > "$ADIR/IDENTITY.md" <<IDMD
      # IDENTITY.md
      - Name: ${ANAME}

      ${GAN}

      ${ANOTES}

      ## Project Context
      This is a Cloud Browser system - ephemeral DigitalOcean droplets provisioned via iOS Shortcuts.
      - YAML configs: dropbox:droplets/yaml/ (current: cloud-browser-v3.17.yaml)
      - Project docs: dropbox:droplets/yaml/CONTEXT.md
      - Memory sync: dropbox:clawdbot-memory/${HN}/ (every 2 min)
      - Previous transcripts restored from Dropbox on boot
      IDMD
      }

      write_identity "$H/clawd/agents/agent1" "$A1N" "$A1NOTES"
      [ -n "$A2T" ] && write_identity "$H/clawd/agents/agent2" "$A2N" "$A2NOTES"
      [ -n "$A3T" ] && write_identity "$H/clawd/agents/agent3" "$A3N" "$A3NOTES"
      [ -n "$A4T" ] && write_identity "$H/clawd/agents/agent4" "$A4N" "$A4NOTES"

      # Create AGENTS.md for each agent
      echo -e "# Agent: ${A1N}\nModel: Claude Opus 4.5\nBe helpful and natural." > $H/clawd/agents/agent1/AGENTS.md
      [ -n "$A2T" ] && echo -e "# Agent: ${A2N}\nModel: GPT-5.2 (reasoning_effort: high)\nBe helpful and natural." > $H/clawd/agents/agent2/AGENTS.md
      [ -n "$A3T" ] && echo -e "# Agent: ${A3N}\nModel: Gemini 3 Pro Preview\nBe helpful and natural." > $H/clawd/agents/agent3/AGENTS.md
      [ -n "$A4T" ] && echo -e "# Agent: ${A4N}\nModel: Claude Opus 4.5\nBe helpful and natural." > $H/clawd/agents/agent4/AGENTS.md

      # Create SOUL.md for each agent (if provided)
      [ -n "$A1SOUL" ] && echo "$A1SOUL" > $H/clawd/agents/agent1/SOUL.md
      [ -n "$A2T" ] && [ -n "$A2SOUL" ] && echo "$A2SOUL" > $H/clawd/agents/agent2/SOUL.md
      [ -n "$A3T" ] && [ -n "$A3SOUL" ] && echo "$A3SOUL" > $H/clawd/agents/agent3/SOUL.md
      [ -n "$A4T" ] && [ -n "$A4SOUL" ] && echo "$A4SOUL" > $H/clawd/agents/agent4/SOUL.md

      # Symlink shared context (TOOLS.md, USER.md, HEARTBEAT.md) to all agent workspaces
      # NOTE: HEARTBEAT.md symlink uses -sf to handle race condition where clawdbot
      # may not have fully initialized agent workspace dirs yet. These symlinks are
      # created AFTER mkdir -p above, so target dirs exist at this point.
      for _a in agent1 agent2 agent3 agent4; do
        _AD="$H/clawd/agents/$_a"
        [ -d "$_AD" ] && {
          ln -sf "$H/clawd/TOOLS.md" "$_AD/TOOLS.md" 2>/dev/null || true
          ln -sf "$H/clawd/USER.md" "$_AD/USER.md" 2>/dev/null || true
          ln -sf "$H/clawd/HEARTBEAT.md" "$_AD/HEARTBEAT.md" 2>/dev/null || true
        }
      done

      # USER.md
      cat > $H/clawd/USER.md <<USERMD
      # USER.md
      $([ -n "$URN" ] && echo "- Name: $URN" || echo "- Name: (learn)")
      $([ -n "$UL" ] && echo "- Location: $UL" || echo "- Location: (learn)")
      $([ -n "$UN" ] && echo -e "\n$UN")
      USERMD

      # BOOTSTRAP.md (one-time instructions)
      [ -n "$BI" ] && echo "$BI" > $H/clawd/agents/agent1/BOOTSTRAP.md

      # Auth profiles JSON
      mkdir -p $H/.clawdbot/agents/main/agent
      cat > $H/.clawdbot/agents/main/agent/auth-profiles.json <<APJ
      {"version":1,"profiles":{"anthropic:default":{"type":"api_key","provider":"anthropic","token":"${AK}"}$([ -n "$OA" ] && echo ",\"openai-codex:default\":{\"type\":\"oauth\",\"provider\":\"openai-codex\",\"access\":\"${OA}\",\"refresh\":\"${OR}\",\"expires\":${OE:-0},\"accountId\":\"${OI}\"}")$([ -n "$GK" ] && echo ",\"google:default\":{\"type\":\"api_key\",\"provider\":\"google\",\"token\":\"${GK}\"}")}}
      APJ

      # Symlink auth-profiles to all agents
      for _ag in agent1 agent2 agent3 agent4; do
        mkdir -p "$H/.clawdbot/agents/$_ag/agent"
        ln -sf "$H/.clawdbot/agents/main/agent/auth-profiles.json" "$H/.clawdbot/agents/$_ag/agent/auth-profiles.json"
      done

      # Update systemd service with full environment (includes NODE_OPTIONS for sqlite)
      cat > /etc/systemd/system/clawdbot.service <<SVC
      [Unit]
      Description=Clawdbot Gateway
      After=network.target desktop.service
      Wants=desktop.service
      [Service]
      Type=simple
      User=$USERNAME
      WorkingDirectory=$H
      ExecStartPre=/bin/sleep 2
      ExecStart=/usr/local/bin/clawdbot gateway --bind lan --port 18789
      ExecStop=+/usr/local/bin/sync-clawdbot-state.sh
      TimeoutStopSec=30
      Restart=always
      RestartSec=3
      Environment=NODE_ENV=production
      Environment=NODE_OPTIONS=--experimental-sqlite
      Environment=PATH=/usr/bin:/usr/local/bin
      Environment=DISPLAY=:10
      Environment=ANTHROPIC_API_KEY=${AK}
      $([ -n "$GK" ] && echo "Environment=GOOGLE_API_KEY=${GK}")
      $([ -n "$GK" ] && echo "Environment=GEMINI_API_KEY=${GK}")
      $([ -n "$BK" ] && echo "Environment=BRAVE_API_KEY=${BK}")
      [Install]
      WantedBy=multi-user.target
      SVC

      systemctl daemon-reload

      chown -R $USERNAME:$USERNAME $H/.clawdbot $H/clawd
      chmod 700 $H/.clawdbot
      chmod 600 $H/.clawdbot/clawdbot.json $H/.clawdbot/clawdbot.full.json $H/.clawdbot/clawdbot.minimal.json 2>/dev/null || true

  - path: /etc/systemd/system/post-boot-check.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Post-boot health check and config upgrade
      After=clawdbot.service network-online.target
      Wants=network-online.target
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/post-boot-check.sh
      RemainAfterExit=yes
      [Install]
      WantedBy=multi-user.target

  - path: /usr/local/bin/post-boot-check.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Post-reboot health check and config upgrade
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      H="/home/$USERNAME"
      TG="/usr/local/bin/tg-notify.sh"
      LOG="/var/log/post-boot-check.log"

      echo "=== Post-boot check: $(date) ===" >> "$LOG"

      # Only run if we need to (sentinel from phase2)
      [ ! -f /var/lib/init-status/needs-post-boot-check ] && {
        echo "No post-boot check needed" >> "$LOG"
        exit 0
      }

      # Wait for clawdbot to stabilize
      sleep 15

      # Check if full config exists
      if [ ! -f "$H/.clawdbot/clawdbot.full.json" ]; then
        echo "No full config found, skipping upgrade" >> "$LOG"
        rm -f /var/lib/init-status/needs-post-boot-check
        exit 0
      fi

      # Apply full config
      echo "Applying full config..." >> "$LOG"
      cp "$H/.clawdbot/clawdbot.full.json" "$H/.clawdbot/clawdbot.json"
      chown $USERNAME:$USERNAME "$H/.clawdbot/clawdbot.json"
      chmod 600 "$H/.clawdbot/clawdbot.json"
      systemctl restart clawdbot

      # Wait generously for 4 agents + 4 telegram bots to initialize
      # No rush here - phase1 bot is already online for user
      sleep 45

      # Health check (3 attempts, generous timeouts)
      HEALTHY=false
      for i in 1 2 3; do
        echo "Health check attempt $i..." >> "$LOG"

        # Check service is active
        if ! systemctl is-active --quiet clawdbot; then
          echo "  Service not active" >> "$LOG"
          sleep 15
          continue
        fi

        # Check gateway responds (try clawdbot health command)
        if timeout 30 su - $USERNAME -c "clawdbot health --json" >> "$LOG" 2>&1; then
          echo "  Gateway healthy" >> "$LOG"
          HEALTHY=true
          break
        fi

        echo "  Gateway not responding" >> "$LOG"
        sleep 15
      done

      if [ "$HEALTHY" = "true" ]; then
        echo "Full config applied successfully" >> "$LOG"
        rm -f /var/lib/init-status/needs-post-boot-check
        rm -f /var/lib/init-status/safe-mode
        rm -f "$H/clawd/agents/agent1/SAFE_MODE.md"
        touch /var/lib/init-status/setup-complete

        $TG "[OK] Fully operational. Full config applied. All systems ready. RDP: port 3389."

      else
        echo "Full config FAILED, reverting to safe mode" >> "$LOG"

        # Restore minimal config
        cp "$H/.clawdbot/clawdbot.minimal.json" "$H/.clawdbot/clawdbot.json"
        chown $USERNAME:$USERNAME "$H/.clawdbot/clawdbot.json"
        chmod 600 "$H/.clawdbot/clawdbot.json"

        # Create safe mode marker
        touch /var/lib/init-status/safe-mode

        # Create SAFE_MODE.md for the bot
        cat > "$H/clawd/agents/agent1/SAFE_MODE.md" <<'SAFEMD'
      # SAFE MODE ACTIVE

      Full configuration failed health checks after reboot. You are running minimal config.
      Browser, skills, and multi-agent features are NOT available.

      ## Your Mission
      Get the full system operational without waiting for user input.

      ## Diagnostic Steps
      1. Check logs: journalctl -u clawdbot -n 100 --no-pager
      2. Run doctor with auto-fix: clawdbot doctor --fix
      3. Compare configs: diff ~/.clawdbot/clawdbot.json ~/.clawdbot/clawdbot.full.json
      4. Check for JSON errors: cat ~/.clawdbot/clawdbot.full.json | jq .

      ## Common Issues
      - Invalid JSON syntax -> fix with jq or manual edit
      - Missing dependencies -> install them
      - Permission issues -> sudo chown -R bot:bot ~/.clawdbot
      - Port conflicts -> check with: ss -tlnp | grep 18789

      ## When Ready to Retry
      1. Fix the issue in ~/.clawdbot/clawdbot.full.json
      2. Message user: "Attempting full config again..."
      3. Run: sudo /usr/local/bin/try-full-config.sh
      4. Report outcome

      ## Keep Trying
      Do not give up after one attempt. Keep investigating and trying until:
      - Full config works (announce success!)
      - You have exhausted all ideas (ask user for specific help)
      SAFEMD
        chown $USERNAME:$USERNAME "$H/clawd/agents/agent1/SAFE_MODE.md"

        # Restart with minimal config
        systemctl restart clawdbot
        sleep 5

        rm -f /var/lib/init-status/needs-post-boot-check

        $TG "[SAFE MODE] Running minimal config. Full config failed health checks. Bot is attempting repairs."
      fi

  - path: /usr/local/bin/try-full-config.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Called by safe-mode bot to attempt full config
      source /etc/droplet.env
      H="/home/$USERNAME"

      echo "Attempting full config at $(date)"

      # Apply full config
      cp "$H/.clawdbot/clawdbot.full.json" "$H/.clawdbot/clawdbot.json"
      chown $USERNAME:$USERNAME "$H/.clawdbot/clawdbot.json"
      chmod 600 "$H/.clawdbot/clawdbot.json"
      systemctl restart clawdbot

      # Wait generously for 4 agents + telegram bots to initialize
      sleep 45

      # Health check
      HEALTHY=false
      for i in 1 2 3; do
        if systemctl is-active --quiet clawdbot; then
          if timeout 30 su - $USERNAME -c "clawdbot health --json" >/dev/null 2>&1; then
            HEALTHY=true
            break
          fi
        fi
        sleep 15
      done

      if [ "$HEALTHY" = "true" ]; then
        rm -f "$H/clawd/agents/agent1/SAFE_MODE.md"
        rm -f /var/lib/init-status/safe-mode
        echo "SUCCESS: Full config now active"
        exit 0
      else
        # Restore minimal config
        cp "$H/.clawdbot/clawdbot.minimal.json" "$H/.clawdbot/clawdbot.json"
        chown $USERNAME:$USERNAME "$H/.clawdbot/clawdbot.json"
        chmod 600 "$H/.clawdbot/clawdbot.json"
        systemctl restart clawdbot
        echo "FAILED: Restored minimal config. Check logs: journalctl -u clawdbot"
        exit 1
      fi

  - path: /home/bot/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-desktop.xml
    defer: true
    content: |
      <?xml version="1.0"?><channel name="xfce4-desktop" version="1.0"><property name="backdrop" type="empty"><property name="screen0" type="empty"><property name="monitorscreen" type="empty"><property name="workspace0" type="empty"><property name="color-style" type="int" value="0"/><property name="image-style" type="int" value="0"/><property name="rgba1" type="array"><value type="double" value="0.17647"/><value type="double" value="0.21569"/><value type="double" value="0.28235"/><value type="double" value="1"/></property></property></property></property></property></channel>

  - path: /home/bot/clawd/TOOLS.md
    defer: true
    content: |
      ### Environment
      Cloud VM (Ubuntu), display :10 shared with user via RDP.

      ### Email
      DO blocks SMTP. Use gmail-api.py for all email:
      - Send: gmail-api.py send "to@email" "Subject" "Body" [--html] [--cc addr] [-a file]
      - List: gmail-api.py list [-n count] [-q "search query"]
      - Read: gmail-api.py read <message_id>
      Requires: google-auth, google-api-python-client (installed via pip)
      Credentials: GMAIL_CLIENT_ID, GMAIL_CLIENT_SECRET, GMAIL_REFRESH_TOKEN from /etc/droplet.env

      ### Browser
      Chrome remote debugging on port 18800.

      ### Calendar
      khal for viewing, vdirsyncer for CalDAV sync.
      - View: khal list [today] [2days]
      - Sync: vdirsyncer sync

      ### Tools
      Chrome, Thunderbird, goplaces, ffmpeg, LibreOffice, rclone, pandoc, khal/vdirsyncer, yt-dlp, ImageMagick, scrot/flameshot, qpdf, jq, gh, vlc, htop/ncdu

      ### Skills
      weather, github, video-frames, goplaces, youtube-transcript, yt-dlp-downloader-skill

  - path: /home/bot/clawd/HEARTBEAT.md
    defer: true
    permissions: "0644"
    content: |
      # HEARTBEAT.md
      - If BOOTSTRAP.md exists, execute it first and delete when done.
      - If BOOT.md exists, execute it on every heartbeat (do NOT delete).
      - If SAFE_MODE.md exists, follow its instructions to repair the system.

  - path: /etc/systemd/system/clawdbot-sync.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Sync Clawdbot memory to Dropbox
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/sync-clawdbot-state.sh
      User=root

  - path: /etc/systemd/system/clawdbot-sync.timer
    permissions: "0644"
    content: |
      [Unit]
      Description=Periodic Clawdbot memory sync
      [Timer]
      OnBootSec=2min
      OnUnitActiveSec=2min
      [Install]
      WantedBy=timers.target

  - path: /usr/local/bin/gmail-api.py
    permissions: "0755"
    content: |
      #!/usr/bin/env python3
      """Gmail API CLI - Use on DO where SMTP is blocked"""
      import argparse,base64,os,sys,mimetypes
      from email.mime.text import MIMEText
      from email.mime.multipart import MIMEMultipart
      from email.mime.base import MIMEBase
      from email import encoders
      try:
        from google.oauth2.credentials import Credentials
        from googleapiclient.discovery import build
      except ImportError:
        sys.exit("Run: pip3 install google-auth google-api-python-client")
      def get_creds():
        cid,csc,rtk=os.environ.get('GMAIL_CLIENT_ID'),os.environ.get('GMAIL_CLIENT_SECRET'),os.environ.get('GMAIL_REFRESH_TOKEN')
        if not all([cid,csc,rtk]):
          # Try bot's .env file first (readable by bot user)
          for envf in [os.path.expanduser('~/.clawdbot/.env'),'/etc/droplet.env']:
            try:
              with open(envf,'r') as f:
                for l in f:
                  l=l.strip()
                  if l.startswith('GMAIL_CLIENT_ID='):cid=cid or l.split('=',1)[1].strip('"')
                  elif l.startswith('GMAIL_CLIENT_SECRET='):csc=csc or l.split('=',1)[1].strip('"')
                  elif l.startswith('GMAIL_REFRESH_TOKEN='):rtk=rtk or l.split('=',1)[1].strip('"')
                  elif l.startswith('GMAIL_CLIENT_ID_B64='):v=l.split('=',1)[1].strip('"');cid=cid or (base64.b64decode(v).decode() if v else None)
                  elif l.startswith('GMAIL_CLIENT_SECRET_B64='):v=l.split('=',1)[1].strip('"');csc=csc or (base64.b64decode(v).decode() if v else None)
                  elif l.startswith('GMAIL_REFRESH_TOKEN_B64='):v=l.split('=',1)[1].strip('"');rtk=rtk or (base64.b64decode(v).decode() if v else None)
            except:pass
            if all([cid,csc,rtk]):break
        if not all([cid,csc,rtk]):sys.exit("Gmail API credentials not configured")
        return Credentials(None,refresh_token=rtk,token_uri="https://oauth2.googleapis.com/token",client_id=cid,client_secret=csc)
      def cmd_send(args):
        svc=build('gmail','v1',credentials=get_creds(),cache_discovery=False)
        msg=MIMEMultipart('mixed');msg['To']=args.to;msg['Subject']=args.subject
        if args.cc:msg['Cc']=args.cc
        msg.attach(MIMEText(args.body,'html' if args.html else 'plain'))
        if args.attach:
          for fp in args.attach:
            if os.path.isfile(fp):
              ct,_=mimetypes.guess_type(fp);ct=ct or 'application/octet-stream';mt,st=ct.split('/',1)
              with open(fp,'rb') as f:
                part=MIMEBase(mt,st);part.set_payload(f.read());encoders.encode_base64(part)
              part.add_header('Content-Disposition','attachment',filename=os.path.basename(fp));msg.attach(part)
        r=svc.users().messages().send(userId='me',body={'raw':base64.urlsafe_b64encode(msg.as_bytes()).decode()}).execute()
        print(f"Sent to {args.to} (ID: {r['id']})")
      def cmd_list(args):
        svc=build('gmail','v1',credentials=get_creds(),cache_discovery=False)
        res=svc.users().messages().list(userId='me',maxResults=args.n,q=args.q or '').execute()
        for msg in res.get('messages',[]):
          m=svc.users().messages().get(userId='me',id=msg['id'],format='metadata',metadataHeaders=['From','Subject','Date']).execute()
          h={x['name']:x['value'] for x in m['payload']['headers']}
          print(f"ID: {msg['id']}\n  From: {h.get('From','?')}\n  Subject: {h.get('Subject','(no subject)')}\n  Date: {h.get('Date','?')}\n")
      def cmd_read(args):
        svc=build('gmail','v1',credentials=get_creds(),cache_discovery=False)
        m=svc.users().messages().get(userId='me',id=args.id,format='full').execute()
        h={x['name']:x['value'] for x in m['payload']['headers']}
        print(f"From: {h.get('From','?')}\nTo: {h.get('To','?')}\nSubject: {h.get('Subject','?')}\nDate: {h.get('Date','?')}\n{'='*60}")
        def get_body(pl):
          if 'body' in pl and pl['body'].get('data'):return base64.urlsafe_b64decode(pl['body']['data']).decode('utf-8',errors='replace')
          if 'parts' in pl:
            for p in pl['parts']:
              if p.get('filename'):continue
              if p['mimeType']=='text/plain' and p['body'].get('data'):return base64.urlsafe_b64decode(p['body']['data']).decode('utf-8',errors='replace')
              if 'parts' in p:
                r=get_body(p);
                if r:return r
          return None
        print(get_body(m['payload']) or "(Could not extract body)")
      def main():
        p=argparse.ArgumentParser();sub=p.add_subparsers(dest='cmd',required=True)
        ps=sub.add_parser('send');ps.add_argument('to');ps.add_argument('subject');ps.add_argument('body');ps.add_argument('--html',action='store_true');ps.add_argument('--cc');ps.add_argument('--attach','-a',action='append')
        pl=sub.add_parser('list');pl.add_argument('-n',type=int,default=10);pl.add_argument('-q',default='')
        pr=sub.add_parser('read');pr.add_argument('id')
        args=p.parse_args();{'send':cmd_send,'list':cmd_list,'read':cmd_read}[args.cmd](args)
      if __name__=='__main__':main()

  - path: /usr/local/bin/set-council-group.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Hot-reload council group ID without rebuilding droplet
      [ -z "$1" ] && { echo "Usage: set-council-group.sh <group_id>"; exit 1; }
      GID="$1"; source /etc/droplet.env
      H="/home/$USERNAME"; CFG="$H/.clawdbot/clawdbot.json"
      [ ! -f "$CFG" ] && { echo "Config not found"; exit 1; }
      cp "$CFG" "$CFG.bak"
      if grep -q '"groups":{' "$CFG"; then
        sed -i "s|\"groups\":{[^}]*}|\"groups\":{\"${GID}\":{\"requireMention\":true},\"*\":{\"requireMention\":true}}|" "$CFG"
      else
        sed -i "s|\"telegram\":{\"enabled\":true|\"telegram\":{\"enabled\":true,\"groups\":{\"${GID}\":{\"requireMention\":true},\"*\":{\"requireMention\":true}}|" "$CFG"
      fi
      echo "$GID" > "$H/clawd/.council-group-id"
      echo "true" > "$H/clawd/.council-enabled"
      chown $USERNAME:$USERNAME "$H/clawd/.council-group-id" "$H/clawd/.council-enabled"
      systemctl restart clawdbot
      sleep 3
      systemctl is-active --quiet clawdbot && echo "Council group set to $GID. Clawdbot restarted." || { echo "Restart failed, restoring backup"; cp "$CFG.bak" "$CFG"; systemctl restart clawdbot; exit 1; }

  - path: /usr/local/bin/mount-dropbox.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      mkdir -p "$HOME/Dropbox"; fusermount -uz "$HOME/Dropbox" 2>/dev/null || true
      rclone mount dropbox: "$HOME/Dropbox" --vfs-cache-mode writes --daemon
      sleep 2 && thunar "$HOME/Dropbox"

  - path: /usr/local/bin/restore-clawdbot-state.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Restore bot-owned files from Dropbox (memory + user identity + transcripts)
      # TOOLS.md is NOT restored - YAML is authoritative for that
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      DBT=$(d "$DROPBOX_TOKEN_B64"); [ -z "$DBT" ] && exit 0
      HN=$(d "$HABITAT_NAME_B64"); HN="${HN:-default}"
      H="/home/$USERNAME"; R="dropbox:clawdbot-memory/${HN}"
      # Restore bot-owned workspace files (not TOOLS.md - YAML manages that)
      for f in MEMORY.md USER.md; do su - $USERNAME -c "rclone copy '$R/$f' '$H/clawd/' 2>/dev/null" || true; done
      # Restore agent memory directories
      for a in agent1 agent2 agent3 agent4; do
        AD="$H/clawd/agents/$a"; [ -d "$AD" ] || continue
        su - $USERNAME -c "rclone copy '$R/agents/${a}/memory/' '$AD/memory/' 2>/dev/null" || true
      done
      # Restore transcripts (session history from previous droplets)
      for a in agent1 agent2 agent3 agent4; do
        TD="$H/.clawdbot/agents/$a/sessions"; mkdir -p "$TD"
        su - $USERNAME -c "rclone copy '$R/agents/${a}/sessions/' '$TD/' --include '*.jsonl' 2>/dev/null" || true
      done
      chown -R $USERNAME:$USERNAME $H/clawd $H/.clawdbot

  - path: /usr/local/bin/sync-clawdbot-state.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      # Sync bot-owned state to Dropbox (memory, user identity, transcripts)
      # TOOLS.md is NOT synced - YAML is authoritative for that
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      DBT=$(d "$DROPBOX_TOKEN_B64"); [ -z "$DBT" ] && exit 0
      HN=$(d "$HABITAT_NAME_B64"); HN="${HN:-default}"
      H="/home/$USERNAME"; R="dropbox:clawdbot-memory/${HN}"
      # Sync bot-owned workspace files
      for f in MEMORY.md USER.md; do [ -f "$H/clawd/$f" ] && su - $USERNAME -c "rclone copy '$H/clawd/$f' '$R/' 2>/dev/null" || true; done
      # Sync agent memory directories
      for a in agent1 agent2 agent3 agent4; do
        AD="$H/clawd/agents/$a"; [ -d "$AD" ] || continue
        su - $USERNAME -c "rclone sync '$AD/memory' '$R/agents/${a}/memory' 2>/dev/null" || true
      done
      # Sync transcripts (copy only, don't delete old sessions from Dropbox)
      for a in agent1 agent2 agent3 agent4; do
        TD="$H/.clawdbot/agents/$a/sessions"
        [ -d "$TD" ] && su - $USERNAME -c "rclone copy '$TD/' '$R/agents/${a}/sessions/' --include '*.jsonl' 2>/dev/null" || true
      done

  - path: /usr/local/bin/schedule-destruct.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      M=$(d "$DESTRUCT_MINS_B64")
      [ -n "$M" ] && [ "$M" != "0" ] && [ "$M" -gt 0 ] 2>/dev/null && systemd-run --unit=self-destruct --on-active=${M}m /usr/local/bin/kill-droplet.sh

  - path: /usr/local/bin/kill-droplet.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      /usr/local/bin/sync-clawdbot-state.sh
      curl -X DELETE -H "Authorization: Bearer $(d "$DO_TOKEN_B64")" "https://api.digitalocean.com/v2/droplets?tag_name=$(d "$HABITAT_NAME_B64")"

  - path: /usr/local/bin/rename-telegram-bots.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      source /etc/droplet.env
      d() { [ -n "$1" ] && echo "$1" | base64 -d 2>/dev/null || echo ""; }
      A1N=$(d "$AGENT1_NAME_B64"); A1N="${A1N:-Claude}"; A1T=$(d "$AGENT1_BOT_TOKEN_B64")
      [ -n "$A1T" ] && curl -s "https://api.telegram.org/bot${A1T}/setMyName" -d "name=${A1N}Bot" > /dev/null
      A2N=$(d "$AGENT2_NAME_B64"); A2N="${A2N:-GPT}"; A2T=$(d "$AGENT2_BOT_TOKEN_B64")
      [ -n "$A2T" ] && curl -s "https://api.telegram.org/bot${A2T}/setMyName" -d "name=${A2N}Bot" > /dev/null
      A3N=$(d "$AGENT3_NAME_B64"); A3N="${A3N:-Gemini}"; A3T=$(d "$AGENT3_BOT_TOKEN_B64")
      [ -n "$A3T" ] && curl -s "https://api.telegram.org/bot${A3T}/setMyName" -d "name=${A3N}Bot" > /dev/null
      A4N=$(d "$AGENT4_NAME_B64"); A4N="${A4N:-Opus}"; A4T=$(d "$AGENT4_BOT_TOKEN_B64")
      [ -n "$A4T" ] && curl -s "https://api.telegram.org/bot${A4T}/setMyName" -d "name=${A4N}Bot" > /dev/null

users:
  - default

runcmd:
  - [ bash, -lc, "systemctl daemon-reload; systemctl enable --now api-server; ufw allow 8080/tcp" ]
  - [ bash, -lc, "systemctl enable post-boot-check.service" ]
  - [ bash, -lc, "/usr/local/bin/schedule-destruct.sh" ]
  - [ bash, -lc, "/usr/local/sbin/phase1-critical.sh" ]
  - [ bash, -lc, "/usr/local/bin/rename-telegram-bots.sh" ]

# Phase 2 kicks off automatically in background from phase1
