#cloud-config
# version: main (slim) -- bootstrap.sh fetches large scripts from GitHub
package_update: false
package_upgrade: false
bootcmd:
  - [bash, -lc, "mkdir -p /var/lib/init-status;[ -f /var/lib/init-status/setup-complete ]&&exit 0;echo 0>/var/lib/init-status/stage;echo 1>/var/lib/init-status/phase;echo \"$(date -u +%Y-%m-%dT%H:%M:%SZ) STAGE=0 PHASE=1 DESC=init\">>/var/log/init-stages.log;systemctl stop apt-daily.timer apt-daily-upgrade.timer apt-daily.service apt-daily-upgrade.service unattended-upgrades 2>/dev/null||true;systemctl disable apt-daily.timer apt-daily-upgrade.timer 2>/dev/null||true;killall -9 unattended-upgr apt apt-get dpkg 2>/dev/null||true"]
  - [bash, -lc, "[ -f /var/lib/init-status/phase2-complete ]&&exit 0;systemctl stop xrdp xrdp-sesman 2>/dev/null||true;systemctl mask xrdp xrdp-sesman 2>/dev/null||true"]
  - [bash, -lc, "[ -f /var/lib/init-status/setup-complete ]&&exit 0;mkdir -p /tmp/downloads;curl -sL https://nodejs.org/dist/v22.12.0/node-v22.12.0-linux-x64.tar.xz -o /tmp/downloads/node.tar.xz& echo $!>/tmp/downloads/node.pid;wget -q -O /tmp/downloads/chrome.deb https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb& echo $!>/tmp/downloads/chrome.pid"]
  - [bash, -lc, "[ -f /var/lib/init-status/setup-complete ]&&[ ! -f /var/lib/init-status/boot-complete ]&&{ echo 11>/var/lib/init-status/stage;echo \"$(date -u +%Y-%m-%dT%H:%M:%SZ) STAGE=11 DESC=ready\">>/var/log/init-stages.log;touch /var/lib/init-status/boot-complete;}||true"]
write_files:
  - path: /etc/hatchery-version
    content: "main"
  - path: /etc/droplet.env
    owner: root:root
    permissions: "0600"
    content: |
      USERNAME="bot"
      SSH_KEY_B64=""
      DO_TOKEN_B64="[[DO_TOKEN_B64]]"
      PASSWORD_B64="[[PASSWORD_B64]]"
      # PLATFORM, DISCORD_*, TELEGRAM_OWNER_ID are extracted from HABITAT_B64
      # by parse-habitat.py -> /etc/habitat-parsed.env (no Shortcut placeholders needed)
      ANTHROPIC_KEY_B64="[[ANTHROPIC_KEY_B64]]"
      BRAVE_KEY_B64="[[BRAVE_KEY_B64]]"
      GOOGLE_API_KEY_B64="[[GOOGLE_API_KEY_B64]]"
      DROPBOX_TOKEN_B64="[[DROPBOX_TOKEN_B64]]"
      EMAIL_B64="[[EMAIL_B64]]"
      IMAP_HOST_B64="[[IMAP_HOST_B64]]"
      SMTP_HOST_B64="[[SMTP_HOST_B64]]"
      EMAIL_PASSWORD_B64="[[EMAIL_PASSWORD_B64]]"
      CALDAV_URL_B64="[[CALDAV_URL_B64]]"
      CALDAV_USER_B64="[[CALDAV_USER_B64]]"
      CALDAV_PASSWORD_B64="[[CALDAV_PASSWORD_B64]]"
      API_SECRET_B64="[[API_SECRET_B64]]"
      GH_TOKEN_B64="[[GH_TOKEN_B64]]"
      GMAIL_CLIENT_ID_B64="[[GMAIL_CLIENT_ID_B64]]"
      GMAIL_CLIENT_SECRET_B64="[[GMAIL_CLIENT_SECRET_B64]]"
      GMAIL_REFRESH_TOKEN_B64="[[GMAIL_REFRESH_TOKEN_B64]]"
      OPENAI_ACCESS_B64="[[OPENAI_ACCESS_B64]]"
      OPENAI_REFRESH_B64="[[OPENAI_REFRESH_B64]]"
      OPENAI_EXPIRES_B64="[[OPENAI_EXPIRES_B64]]"
      OPENAI_ACCOUNT_ID_B64="[[OPENAI_ACCOUNT_ID_B64]]"
      HABITAT_B64="[[HABITAT_B64]]"
      AGENT_LIB_B64="[[AGENT_LIB_B64]]"
  - path: /etc/needrestart/conf.d/99-autorestart.conf
    permissions: "0644"
    content: |
      $nrconf{restart} = 'a';
      $nrconf{blacklist_rc} = [qr/^cloud-init/, qr/^cloud-final/, qr/^cloud-config/];
  - path: /etc/ssh/sshd_config.d/99-password-auth.conf
    permissions: "0644"
    content: |
      PasswordAuthentication yes
      PermitRootLogin yes
  - path: /usr/local/bin/set-stage.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      echo "$1">/var/lib/init-status/stage
      echo "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ) STAGE=$1 PHASE=$(cat /var/lib/init-status/phase 2>/dev/null||echo 1) DESC=$2">>/var/log/init-stages.log
  - path: /usr/local/bin/set-phase.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      echo "$1">/var/lib/init-status/phase
      echo "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ) PHASE=$1 DESC=$2">>/var/log/init-stages.log
  - path: /usr/local/bin/parse-habitat.py
    permissions: "0755"
    content: |
      #!/usr/bin/env python3
      import json,base64,os,sys
      d=lambda v:base64.b64decode(v).decode() if v else ""
      b=lambda s:base64.b64encode((s or"").encode()).decode()
      hr=os.environ.get('HABITAT_B64','')
      lr=os.environ.get('AGENT_LIB_B64','')
      if not hr:print("ERROR: HABITAT_B64 not set",file=sys.stderr);sys.exit(1)
      try:h=json.loads(d(hr))
      except Exception as e:print(f"ERROR: {e}",file=sys.stderr);sys.exit(1)
      lib={}
      if lr:
          try:lib=json.loads(d(lr))
          except:pass
      with open('/etc/habitat.json','w') as f:json.dump(h,f,indent=2)
      os.chmod('/etc/habitat.json',0o600)
      p=h.get("platform","telegram");ag=h.get("agents",[])
      dc=h.get("discord",{});tg=h.get("telegram",{});co=h.get("council",{})
      ct=co.get("telegram",{})
      cgi=ct.get("groupId",co.get("groupId",h.get("councilGroupId","")))
      toi=tg.get("ownerId","")
      w=[]
      for k,v in [("HABITAT_NAME",h["name"]),("HABITAT_NAME_B64",b(h["name"])),
          ("DESTRUCT_MINS",h.get("destructMinutes",0)),("DESTRUCT_MINS_B64",b(str(h.get("destructMinutes",0)))),
          ("BG_COLOR",h.get("bgColor","2D3748")),("PLATFORM",p),("PLATFORM_B64",b(p)),
          ("DISCORD_GUILD_ID",dc.get("serverId","")),("DISCORD_GUILD_ID_B64",b(dc.get("serverId",""))),
          ("DISCORD_OWNER_ID",dc.get("ownerId","")),("DISCORD_OWNER_ID_B64",b(dc.get("ownerId",""))),
          ("TELEGRAM_OWNER_ID",toi),("TELEGRAM_OWNER_ID_B64",b(toi)),("TELEGRAM_USER_ID_B64",b(toi)),
          ("COUNCIL_GROUP_ID",cgi),("COUNCIL_GROUP_NAME",co.get("groupName","")),
          ("COUNCIL_JUDGE",co.get("judge","")),("HABITAT_DOMAIN",h.get("domain","")),
          ("GLOBAL_IDENTITY_B64",b(h.get("globalIdentity",""))),("GLOBAL_BOOT_B64",b(h.get("globalBoot",""))),
          ("GLOBAL_BOOTSTRAP_B64",b(h.get("globalBootstrap",""))),("GLOBAL_SOUL_B64",b(h.get("globalSoul",""))),
          ("GLOBAL_AGENTS_B64",b(h.get("globalAgents",""))),("GLOBAL_USER_B64",b(h.get("globalUser",""))),
          ("AGENT_COUNT",len(ag))]:
          w.append(f'{k}="{v}"')
      for i,ar in enumerate(ag):
          n=i+1;nm=ar["agent"];le=lib.get(nm,{})
          mo=ar.get("model")or le.get("model","anthropic/claude-opus-4-5")
          tt=ar.get("telegramBotToken",ar.get("botToken",""));dt=ar.get("discordBotToken","")
          for k,v in [("NAME",nm),("NAME_B64",b(nm)),("BOT_TOKEN",tt),("BOT_TOKEN_B64",b(tt)),
              ("TELEGRAM_BOT_TOKEN",tt),("TELEGRAM_BOT_TOKEN_B64",b(tt)),
              ("DISCORD_BOT_TOKEN",dt),("DISCORD_BOT_TOKEN_B64",b(dt)),("MODEL",mo),
              ("IDENTITY_B64",b(le.get("identity",""))),("SOUL_B64",b(le.get("soul",""))),
              ("AGENTS_B64",b(le.get("agents",""))),("BOOT_B64",b(le.get("boot",""))),
              ("BOOTSTRAP_B64",b(le.get("bootstrap",""))),("USER_B64",b(le.get("user","")))]:
              w.append(f'AGENT{n}_{k}="{v}"')
      with open('/etc/habitat-parsed.env','w') as f:f.write('\n'.join(w)+'\n')
      os.chmod('/etc/habitat-parsed.env',0o600)
      print(f"Parsed habitat '{h['name']}' with {len(ag)} agents (platform: {p})")
  - path: /usr/local/bin/tg-notify.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -a;source /etc/droplet.env;set +a
      d(){ [ -n "$1" ]&&echo "$1"|base64 -d 2>/dev/null||echo "";}
      [ ! -f /etc/habitat-parsed.env ]&&python3 /usr/local/bin/parse-habitat.py 2>/dev/null
      [ -f /etc/habitat-parsed.env ]&&source /etc/habitat-parsed.env
      P="${PLATFORM:-$(d "$PLATFORM_B64")}";P="${P:-telegram}";MSG="$1";[ -z "$MSG" ]&&exit 1
      stg(){ local T="${AGENT1_BOT_TOKEN}" U=$(d "$TELEGRAM_USER_ID_B64");[ -z "$T" ]||[ -z "$U" ]&&return 1
        curl -sf --max-time 10 "https://api.telegram.org/bot${T}/sendMessage" -d "chat_id=${U}" -d "text=${MSG}">/dev/null 2>&1;}
      sdc(){ local B="${AGENT1_DISCORD_BOT_TOKEN}" O="${DISCORD_OWNER_ID:-$(d "$DISCORD_OWNER_ID_B64")}";[ -z "$B" ]||[ -z "$O" ]&&return 1
        local R=$(curl -sf --max-time 10 -XPOST "https://discord.com/api/v10/users/@me/channels" -H "Authorization: Bot ${B}" -H "Content-Type: application/json" -d "{\"recipient_id\":\"${O}\"}" 2>/dev/null)
        [ -z "$R" ]&&return 1;local C=$(echo "$R"|python3 -c "import sys,json;print(json.load(sys.stdin).get('id',''))" 2>/dev/null);[ -z "$C" ]&&return 1
        curl -sf --max-time 10 -XPOST "https://discord.com/api/v10/channels/${C}/messages" -H "Authorization: Bot ${B}" -H "Content-Type: application/json" \
          -d "{\"content\":$(echo "$MSG"|python3 -c 'import sys,json;print(json.dumps(sys.stdin.read().strip()))')}">/dev/null 2>&1;}
      case "$P" in telegram)stg||exit 1;;discord)sdc||exit 1;;both)stg;T=$?;sdc;D=$?;[ $T -ne 0 ]&&[ $D -ne 0 ]&&exit 1;;*)stg;exit $?;;esac
  - path: /usr/local/bin/set-council-group.sh
    permissions: "0755"
    content: |
      #!/bin/bash
      set -a;source /etc/droplet.env;set +a
      d(){ [ -n "$1" ]&&echo "$1"|base64 -d 2>/dev/null||echo "";}
      P="${PLATFORM:-$(d "$PLATFORM_B64")}";[ "${P:-telegram}" = "discord" ]&&exit 0
      exec /usr/local/bin/set-council-group.telegram.sh "$@"
  - path: /usr/local/bin/api-server.py
    permissions: "0755"
    content: |
      #!/usr/bin/env python3
      # =============================================================================
      # api-server.py -- Droplet Status API (HTTP server on port 8080)
      # =============================================================================
      # Purpose:  Lightweight HTTP API exposing droplet provisioning status.
      #           Provides status, health, config endpoints for droplet management.
      #
      # Endpoints:
      #   GET  /status  -- Full status JSON (phase, stage, services, safe_mode)
      #   GET  /health  -- Health check (200 if bot online, 503 if not)
      #   GET  /stages  -- Raw init-stages.log text
      #   GET  /log     -- Last 8KB of bootstrap/phase logs
      #   GET  /config  -- Config file status (no sensitive data)
      #   GET  /config/status -- API upload status only (no auth required)
      #   POST /sync    -- Trigger openclaw state sync to Dropbox
      #   POST /prepare-shutdown -- Sync state and stop openclaw for shutdown
      #   POST /config/upload -- Upload habitat and/or agents JSON
      #   POST /config/apply  -- Apply uploaded config and restart
      #
      # Dependencies: systemctl, /usr/local/bin/sync-openclaw-state.sh,
      #               /usr/local/bin/apply-config.sh
      #
      # Original: /usr/local/bin/api-server.py (in hatch.yaml write_files)
      # =============================================================================
      import http.server,socketserver,subprocess,json,os,base64,hmac,hashlib,time
      PORT=8080
      API_SECRET=os.getenv('API_SECRET','')
      API_BIND_ADDRESS=os.getenv('API_BIND_ADDRESS','127.0.0.1')
      HABITAT_PATH='/etc/habitat.json'
      AGENTS_PATH='/etc/agents.json'
      MARKER_PATH='/etc/config-api-uploaded'
      APPLY_SCRIPT='/usr/local/bin/apply-config.sh'
      P1_STAGES={0:"init",1:"preparing",2:"installing-bot",3:"bot-online"}
      P2_STAGES={4:"desktop-environment",5:"developer-tools",6:"browser-tools",7:"desktop-services",8:"skills-apps",9:"remote-access",10:"finalizing",11:"ready"}
      
      def check_service(name):
        try:r=subprocess.run(["systemctl","is-active",name],capture_output=True,timeout=5);return r.stdout.decode().strip()=="active"
        except:return False
      
      def get_status():
        s,p=0,1
        try:
          with open('/var/lib/init-status/stage','r') as f:s=int(f.read().strip())
          with open('/var/lib/init-status/phase','r') as f:p=int(f.read().strip())
        except:pass
        p1_done=os.path.exists('/var/lib/init-status/phase1-complete')
        p2_done=os.path.exists('/var/lib/init-status/phase2-complete')
        setup_done=os.path.exists('/var/lib/init-status/setup-complete')
        bot_online=check_service('clawdbot')
        svc={}
        if p2_done or setup_done:
          for sv in ['clawdbot','xrdp','desktop','x11vnc']:svc[sv]=check_service(sv)
        desc=P1_STAGES.get(s) if p==1 else P2_STAGES.get(s,f"stage-{s}")
        safe_mode=os.path.exists('/var/lib/init-status/safe-mode')
        return {"phase":p,"stage":s,"desc":desc,"bot_online":bot_online,"phase1_complete":p1_done,"phase2_complete":p2_done,"ready":setup_done and bot_online,"safe_mode":safe_mode,"services":svc if svc else None}
      
      def validate_config_upload(data):
        """Validate config upload request data."""
        errors=[]
        if "habitat" in data and not isinstance(data["habitat"],dict):errors.append("habitat must be an object")
        if "agents" in data and not isinstance(data["agents"],dict):errors.append("agents must be an object")
        if "apply" in data and not isinstance(data["apply"],bool):errors.append("apply must be a boolean")
        return errors
      
      def write_config_file(path,data):
        """Write config data to file with secure permissions."""
        try:
          with open(path,'w') as f:json.dump(data,f,indent=2)
          os.chmod(path,0o600)
          return {"ok":True,"path":path}
        except Exception as e:return {"ok":False,"error":str(e)}
      
      def write_upload_marker():
        """Write API upload marker with timestamp.
        
        Creates /etc/config-api-uploaded file with timestamp to indicate successful
        config upload via POST /config/upload endpoint. Used by /config/status to
        report upload state.
        
        Logs success/failure in structured format to stderr. Failures are non-fatal
        since upload status can still be determined via API (file existence check).
        
        Returns:
          dict: {"ok": bool, "path": str, "error": str (if failed)}
        """
        import sys
        timestamp = time.time()
        
        try:
          with open(MARKER_PATH, 'w') as f:
            f.write(str(timestamp))
          os.chmod(MARKER_PATH, 0o600)
          
          # Log success (structured format for parsing/monitoring)
          log_entry = json.dumps({
            "event": "upload_marker_written",
            "path": MARKER_PATH,
            "timestamp": timestamp,
            "success": True
          })
          print(log_entry, file=sys.stderr)
          
          return {"ok": True, "path": MARKER_PATH}
          
        except PermissionError as e:
          error_msg = f"Permission denied writing marker: {e}"
          log_entry = json.dumps({
            "event": "upload_marker_write_failed",
            "path": MARKER_PATH,
            "timestamp": timestamp,
            "success": False,
            "error": "PermissionError",
            "details": str(e)
          })
          print(log_entry, file=sys.stderr)
          return {"ok": False, "error": error_msg}
          
        except OSError as e:
          # Covers: disk full, directory doesn't exist, filesystem errors
          error_msg = f"OS error writing marker: {e}"
          log_entry = json.dumps({
            "event": "upload_marker_write_failed",
            "path": MARKER_PATH,
            "timestamp": timestamp,
            "success": False,
            "error": "OSError",
            "details": str(e)
          })
          print(log_entry, file=sys.stderr)
          return {"ok": False, "error": error_msg}
          
        except Exception as e:
          # Catch-all for unexpected errors
          error_msg = f"Unexpected error writing marker: {e}"
          log_entry = json.dumps({
            "event": "upload_marker_write_failed",
            "path": MARKER_PATH,
            "timestamp": timestamp,
            "success": False,
            "error": type(e).__name__,
            "details": str(e)
          })
          print(log_entry, file=sys.stderr)
          return {"ok": False, "error": error_msg}
      
      def get_config_status():
        """Get current config file status without exposing sensitive data."""
        result={"habitat_exists":os.path.exists(HABITAT_PATH),"agents_exists":os.path.exists(AGENTS_PATH)}
        if result["habitat_exists"]:
          stat=os.stat(HABITAT_PATH);result["habitat_modified"]=stat.st_mtime
          try:
            with open(HABITAT_PATH,'r') as f:h=json.load(f)
            result["habitat_name"]=h.get("name","")
            result["habitat_agent_count"]=len(h.get("agents",[]))
          except:pass
        if result["agents_exists"]:
          stat=os.stat(AGENTS_PATH);result["agents_modified"]=stat.st_mtime
          try:
            with open(AGENTS_PATH,'r') as f:a=json.load(f)
            result["agents_names"]=list(a.keys())
          except:pass
        # Check API upload marker (issue #115)
        if os.path.exists(MARKER_PATH):
          result["api_uploaded"]=True
          try:
            with open(MARKER_PATH,'r') as f:result["api_uploaded_at"]=float(f.read().strip())
          except:pass
        else:
          result["api_uploaded"]=False
        return result
      
      def get_config_upload_status():
        """Get simple config upload status for unauthenticated endpoint (issue #130)."""
        result={"api_uploaded":False,"api_uploaded_at":None}
        if os.path.exists(MARKER_PATH):
          result["api_uploaded"]=True
          try:
            with open(MARKER_PATH,'r') as f:result["api_uploaded_at"]=float(f.read().strip())
          except:pass
        return result
      
      def trigger_config_apply():
        """Trigger config apply script asynchronously."""
        try:subprocess.Popen([APPLY_SCRIPT]);return {"ok":True,"restarting":True}
        except Exception as e:return {"ok":False,"error":str(e)}
      
      def verify_hmac_auth(timestamp_header, signature_header, method, path, body):
        """Verify HMAC-SHA256 signature for authenticated endpoints.
      
        Signature binds:
        - timestamp (replay protection)
        - HTTP method + path (prevents cross-endpoint replay/substitution)
        - request body (integrity)
      
        Message format:
          "{timestamp}.{method}.{path}.{body}" where body is UTF-8 JSON string.
        """
        if not API_SECRET:
          return False
        if not timestamp_header or not signature_header:
          return False
        try:
          timestamp = int(timestamp_header)
          now = int(time.time())
          if abs(now - timestamp) > 300:
            return False
      
          b = body.decode('utf-8') if isinstance(body, (bytes, bytearray)) else (body or '')
          msg = f"{timestamp}.{method}.{path}.{b}"
          expected_sig = hmac.new(API_SECRET.encode(), msg.encode(), hashlib.sha256).hexdigest()
          return hmac.compare_digest(signature_header, expected_sig)
        except Exception:
          return False
      
      class H(http.server.BaseHTTPRequestHandler):
        def log_message(self,*a):pass
        
        def send_json(self,code,data):
          self.send_response(code);self.send_header('Content-type','application/json');self.end_headers()
          self.wfile.write(json.dumps(data).encode())
        
        def do_GET(self):
          if self.path=='/status':
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers();self.wfile.write(json.dumps(get_status()).encode())
          elif self.path=='/health':
            s=get_status();code=200 if s.get('bot_online') else 503;self.send_response(code);self.send_header('Content-type','application/json');self.end_headers();self.wfile.write(json.dumps({"healthy":s.get('bot_online',False),"phase":s.get('phase'),"desc":s.get('desc'),"safe_mode":s.get('safe_mode',False)}).encode())
          elif self.path=='/stages':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            # Require auth: stages/log/config may contain sensitive info
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, b''):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            self.send_response(200);self.send_header('Content-type','text/plain');self.end_headers()
            try:
              with open('/var/log/init-stages.log','r') as f:self.wfile.write(f.read().encode())
            except:self.wfile.write(b"No log")
          elif self.path=='/log':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, b''):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            self.send_response(200);self.send_header('Content-type','text/plain');self.end_headers()
            for lf in ['/var/log/bootstrap.log','/var/log/phase1.log','/var/log/phase2.log','/var/log/cloud-init-output.log']:
              try:
                self.wfile.write(f"\n=== {lf} ===\n".encode())
                with open(lf,'r') as f:self.wfile.write(f.read()[-8192:].encode())
              except:self.wfile.write(f"  (not found)\n".encode())
          elif self.path=='/config/status':
            # Unauthenticated endpoint - returns only api_uploaded status (no sensitive data)
            self.send_json(200,get_config_upload_status())
          elif self.path=='/config':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, b''):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            self.send_json(200,get_config_status())
          else:self.send_response(404);self.end_headers()
        
        def do_POST(self):
          content_length=int(self.headers.get('Content-Length',0))
          body=self.rfile.read(content_length) if content_length else b'{}'
          
          if self.path=='/sync':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, body):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers()
            try:r=subprocess.run("/usr/local/bin/sync-openclaw-state.sh",shell=True,capture_output=True,timeout=60);self.wfile.write(json.dumps({"ok":r.returncode==0}).encode())
            except Exception as x:self.wfile.write(json.dumps({"ok":False,"error":str(x)}).encode())
          
          elif self.path=='/prepare-shutdown':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, body):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            
            self.send_response(200);self.send_header('Content-type','application/json');self.end_headers()
            try:subprocess.run("/usr/local/bin/sync-openclaw-state.sh",shell=True,timeout=60);subprocess.run("systemctl stop clawdbot",shell=True,timeout=30);self.wfile.write(json.dumps({"ok":True,"ready_for_shutdown":True}).encode())
            except Exception as x:self.wfile.write(json.dumps({"ok":False,"error":str(x)}).encode())
          
          elif self.path=='/config/upload':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, body):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            
            try:
              data=json.loads(body)
            except json.JSONDecodeError as e:
              self.send_json(400,{"ok":False,"error":f"Invalid JSON: {e}"});return
            
            errors=validate_config_upload(data)
            if errors:
              self.send_json(400,{"ok":False,"errors":errors});return
            
            files_written=[]
            
            # Write habitat config
            if "habitat" in data:
              result=write_config_file(HABITAT_PATH,data["habitat"])
              if not result["ok"]:
                self.send_json(500,{"ok":False,"error":f"Failed to write habitat: {result.get('error')}"});return
              files_written.append(HABITAT_PATH)
            
            # Write agents library
            if "agents" in data:
              result=write_config_file(AGENTS_PATH,data["agents"])
              if not result["ok"]:
                self.send_json(500,{"ok":False,"error":f"Failed to write agents: {result.get('error')}"});return
              files_written.append(AGENTS_PATH)
            
            # Write upload marker if any files were written
            if files_written:
              write_upload_marker()
            
            # Apply if requested
            applied=False
            if data.get("apply"):
              apply_result=trigger_config_apply()
              if not apply_result["ok"]:
                self.send_json(500,{"ok":False,"error":f"Failed to apply: {apply_result.get('error')}","files_written":files_written});return
              applied=True
            
            self.send_json(200,{"ok":True,"files_written":files_written,"applied":applied})
          
          elif self.path=='/config/apply':
            timestamp=self.headers.get('X-Timestamp')
            signature=self.headers.get('X-Signature')
            if not verify_hmac_auth(timestamp, signature, self.command, self.path, body):
              self.send_json(403,{"ok":False,"error":"Forbidden"});return
            
            result=trigger_config_apply()
            self.send_json(200 if result["ok"] else 500,result)
          
          else:
            self.send_response(404);self.end_headers()
      
      class R(socketserver.TCPServer):allow_reuse_address=True
      if __name__=='__main__':
        # SECURITY MODEL:
        # - Default: 127.0.0.1 (localhost only, secure-by-default)
        # - Enable remote access: set remoteApi: true in habitat config
        # - Advanced override: apiBindAddress in habitat (takes precedence)
        # - /status, /health: Public (read-only, no secrets, needed for polling)
        # - /stages, /log, /config: HMAC auth required (may contain sensitive info)
        # - /config/upload, /config/apply: HMAC auth required (mutation endpoints)
        bind_addr = API_BIND_ADDRESS if API_BIND_ADDRESS != '0.0.0.0' else ''
        print(f"[api-server] Starting on {API_BIND_ADDRESS}:{PORT}")
        with R((bind_addr,PORT),H) as h:h.serve_forever()
      
  - path: /etc/systemd/system/post-boot-check.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Post-boot health check
      After=clawdbot.service network-online.target
      Wants=network-online.target
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/post-boot-check.sh
      RemainAfterExit=yes
      [Install]
      WantedBy=multi-user.target
  - path: /etc/systemd/system/clawdbot-sync.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Sync Clawdbot memory to Dropbox
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/sync-openclaw-state.sh
      User=root
  - path: /etc/systemd/system/clawdbot-sync.timer
    permissions: "0644"
    content: |
      [Unit]
      Description=Periodic Clawdbot memory sync
      [Timer]
      OnBootSec=2min
      OnUnitActiveSec=2min
      [Install]
      WantedBy=timers.target
  - path: /usr/local/bin/bootstrap.sh
    permissions: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail
      set -a;source /etc/droplet.env;source /etc/habitat-parsed.env 2>/dev/null||true;set +a
      REPO="dfrysinger/hatchery";DIR="/opt/hatchery"
      VER=$(cat /etc/hatchery-version 2>/dev/null||echo "main")
      log(){ echo "[bootstrap] $*";}
      notify(){ [ -x /usr/local/bin/tg-notify.sh ]&&/usr/local/bin/tg-notify.sh "$1" 2>/dev/null||true;}
      fetch(){ local u="$1" d="$2" i;for i in 1 2 3;do curl -fSL --max-time 60 -o "$d" "$u"&&return 0;sleep $((i*5));done;notify "bootstrap: fetch failed -- $u";return 1;}
      mkdir -p "$DIR";T=$(mktemp)
      if [ "$VER" = "main" ];then
        log "Fetching main";fetch "https://github.com/${REPO}/archive/refs/heads/main.tar.gz" "$T"
        tar -xzf "$T" --strip-components=1 -C "$DIR"
      else
        log "Fetching v${VER}";S=$(mktemp);BU="https://github.com/${REPO}/releases/download/v${VER}"
        fetch "${BU}/hatchery-${VER}.tar.gz" "$T"
        if fetch "${BU}/sha256sums.txt" "$S" 2>/dev/null;then
          E=$(grep "hatchery-${VER}.tar.gz" "$S"|awk '{print $1}');A=$(sha256sum "$T"|awk '{print $1}')
          [ "$E" != "$A" ]&&{ notify "bootstrap: SHA256 mismatch";exit 1;}
        fi
        tar -xzf "$T" -C "$DIR";rm -f "$S"
      fi
      rm -f "$T";chmod +x "$DIR"/scripts/*.sh 2>/dev/null||true
      for f in "$DIR"/scripts/*.sh;do bn=$(basename "$f")
        case "$bn" in bootstrap.sh);;phase1-critical.sh|phase2-background.sh|build-full-config.sh)cp "$f" /usr/local/sbin/;;*)cp "$f" /usr/local/bin/;;esac;done
      for f in "$DIR"/scripts/*.py;do [ -f "$f" ]&&cp "$f" /usr/local/bin/&&chmod 755 "/usr/local/bin/$(basename "$f")";done
      [ -f "$DIR/gmail-api.py" ]&&cp "$DIR/gmail-api.py" /usr/local/bin/gmail-api.py&&chmod 755 /usr/local/bin/gmail-api.py
      [ -f "$DIR/set-council-group.sh" ]&&cp "$DIR/set-council-group.sh" /usr/local/bin/set-council-group.telegram.sh&&chmod 755 /usr/local/bin/set-council-group.telegram.sh
      chmod +x /usr/local/sbin/*.sh /usr/local/bin/*.sh 2>/dev/null||true
      notify "bootstrap: hatchery ${VER} installed -- starting phase1"
      /usr/local/sbin/phase1-critical.sh
users:
  - default
runcmd:
  - [bash, -lc, "systemctl daemon-reload;systemctl enable --now api-server;ufw allow 8080/tcp"]
  - [bash, -lc, "systemctl enable post-boot-check.service"]
  - [bash, -lc, "set -a;source /etc/droplet.env;set +a;python3 /usr/local/bin/parse-habitat.py"]
  - [bash, -lc, "/usr/local/bin/bootstrap.sh>>/var/log/bootstrap.log 2>&1"]
  - [bash, -lc, "/usr/local/bin/schedule-destruct.sh"]
  - [bash, -lc, "/usr/local/bin/rename-bots.sh"]
